
[splunk_rest_shcluster_config_shc_kv_store_lookup_gen]
disabled = 0
enableSched = 1
cron_schedule = 40 5 * * *
schedule_window = 0
schedule_priority = highest
allow_skew = 0
run_on_startup = 0
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | rest /services/shcluster/config splunk_server_group=dmc_group_search_head timeout=0 \
| rename "eai:acl.*" AS "alert*", "eai:*" AS "*" , splunk_server AS Splunk_Instance \
| fields - "perms.*", "can_*", id, published, removable, modifiable \
| fields Splunk_Instance shcluster_label mode conf_deploy_fetch_url adhoc_searchhead replication_factor replication_port replication_use_ssl async_replicate_on_proxy register_replication_address captain_is_adhoc_searchhead decommission_search_jobs_wait_secs dynamic_captain heartbeat_period manual_detention max_peer_rep_load percent_peers_to_restart ping_flag preferred_captain quiet_period rolling_restart cxn_timeout heartbeat_timeout rcv_timeout send_timeout rep_cxn_timeout rep_max_rcv_timeout rep_max_send_timeout rep_rcv_timeout rep_send_timeout restart_timeout \
| rex field=conf_deploy_fetch_url "https?://(?<shcluster_label_tmp>.*?)[.:]" \
| eval shcluster_label = if (isnull(shcluster_label) OR shcluster_label="", shcluster_label_tmp, shcluster_label) \
| eval shcluster_label = if (isnull(shcluster_label) OR shcluster_label="", Splunk_Instance, shcluster_label) \
| stats \
    last(*) AS * \
    BY Splunk_Instance \
| eval shcluster_label = lower(shcluster_label) , Splunk_Instance = lower(Splunk_Instance) \
| table Splunk_Instance shcluster_label mode conf_deploy_fetch_url adhoc_searchhead replication_factor replication_port replication_use_ssl async_replicate_on_proxy register_replication_address captain_is_adhoc_searchhead decommission_search_jobs_wait_secs dynamic_captain heartbeat_period manual_detention max_peer_rep_load percent_peers_to_restart ping_flag preferred_captain quiet_period rolling_restart cxn_timeout heartbeat_timeout rcv_timeout send_timeout rep_cxn_timeout rep_max_rcv_timeout rep_max_send_timeout rep_rcv_timeout rep_send_timeout restart_timeout \
| outputlookup splunk_rest_shcluster_config_shc_kv_store_lookup createinapp=true create_empty=true override_if_empty=false\
| stats count

[splunk_cities_geo_sh_csv_lookup_report]
disabled = 0
enableSched = 0
schedule_window = auto
schedule_priority = default
allow_skew = 50%
run_on_startup = 0
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | inputlookup splunk_cities_geo_sh_csv_lookup \
| fields country region city region_code country_iso2 country_iso3 subregion latitude longitude \
| append \
    [| makeresults \
    | fields - _time \
    | eval country="United States" , region="New York" , city="Stormville", region_code="NY", country_iso2="US", country_iso3="USA", subregion="Northern America", latitude="41.5704", longitude="-73.7454" \
    | fields country region city region_code country_iso2 country_iso3 subregion latitude longitude ] \
| fillnull value="Undefined" region \
| stats last(*) as * by country region cities\
| eval region=if(region="Undefined", null(), region) \
| sort 0 country region city \
| table country region city region_code country_iso2 country_iso3 subregion latitude longitude \
| `gmc_comment("| outputlookup splunk_cities_geo_sh_csv_lookup createinapp=true create_empty=true override_if_empty=false | stats count")`

[splunk_rest_configs_conf_files_all_kv_store_lookup_gen]
disabled = 0
enableSched = 1
cron_schedule = 0 6 * * *
schedule_window = 0
schedule_priority = default
allow_skew = 0
run_on_startup = 0
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | rest /servicesNS/-/-/configs/conf-limits splunk_server_group="*" timeout=0 \
| rename eai:acl.app as app, eai:acl.sharing as sharing \
| fields - published id eai* null* \
| eval stanza = title \
| fields title author splunk_server app sharing stanza ** \
| eval author = if(author="nobody", "system", author) , title="[".title."]" \
| foreach * \
    [ eval title = if("<<FIELD>>"="author" OR "<<FIELD>>"="splunk_server" OR "<<FIELD>>"="app" OR "<<FIELD>>"="sharing" OR "<<FIELD>>"="title" OR "<<FIELD>>"="stanza" OR '<<FIELD>>'="", title, mvappend (title, "<<FIELD>>"." = ".'<<FIELD>>'." "))] \
| rename splunk_server AS Splunk_Instance \
| eval title=mvjoin(title, "###") , config_file="limits.conf" \
| fields Splunk_Instance config_file app sharing author stanza title updated \
| append \
    [| rest /servicesNS/-/-/configs/conf-server splunk_server_group="*" timeout=0 \
    | rename eai:acl.app as app, eai:acl.sharing as sharing \
    | fields - published id eai* null* \
    | eval stanza = title \
    | fields title author splunk_server app sharing stanza ** \
    | eval author = if(author="nobody", "system", author) , title="[".title."]" \
    | foreach * \
        [ eval title = if("<<FIELD>>"="author" OR "<<FIELD>>"="splunk_server" OR "<<FIELD>>"="app" OR "<<FIELD>>"="sharing" OR "<<FIELD>>"="title" OR "<<FIELD>>"="stanza" OR '<<FIELD>>'="", title, mvappend (title, "<<FIELD>>"." = ".'<<FIELD>>'." "))] \
    | rename splunk_server AS Splunk_Instance \
    | eval title=mvjoin(title, "###") , config_file="server.conf" \
    | fields Splunk_Instance config_file app sharing author stanza title updated \
        ] \
| append \
    [| rest /servicesNS/-/-/configs/conf-distsearch splunk_server_group="*" timeout=0 \
    | rename eai:acl.app as app, eai:acl.sharing as sharing \
    | fields - published id eai* null* \
    | eval stanza = title \
    | fields title author splunk_server app sharing stanza ** \
    | eval author = if(author="nobody", "system", author) , title="[".title."]" \
    | foreach * \
        [ eval title = if("<<FIELD>>"="author" OR "<<FIELD>>"="splunk_server" OR "<<FIELD>>"="app" OR "<<FIELD>>"="sharing" OR "<<FIELD>>"="title" OR "<<FIELD>>"="stanza" OR '<<FIELD>>'="", title, mvappend (title, "<<FIELD>>"." = ".'<<FIELD>>'." "))] \
    | rename splunk_server AS Splunk_Instance \
    | eval title=mvjoin(title, "###") , config_file="distsearch.conf" \
    | fields Splunk_Instance config_file app sharing author stanza title updated\
        ] \
| append \
    [| rest /servicesNS/-/-/configs/conf-outputs splunk_server_group="*" timeout=0 \
    | rename eai:acl.app as app, eai:acl.sharing as sharing \
    | fields - published id eai* null* \
    | eval stanza = title \
    | fields title author splunk_server app sharing stanza ** \
    | eval author = if(author="nobody", "system", author) , title="[".title."]" \
    | foreach * \
        [ eval title = if("<<FIELD>>"="author" OR "<<FIELD>>"="splunk_server" OR "<<FIELD>>"="app" OR "<<FIELD>>"="sharing" OR "<<FIELD>>"="title" OR "<<FIELD>>"="stanza" OR '<<FIELD>>'="", title, mvappend (title, "<<FIELD>>"." = ".'<<FIELD>>'." "))] \
    | rename splunk_server AS Splunk_Instance \
    | eval title=mvjoin(title, "###") , config_file="outputs.conf" \
    | fields Splunk_Instance config_file app sharing author stanza title updated\
        ] \
| append \
    [| rest /servicesNS/-/-/configs/conf-web splunk_server_group="*" timeout=0 \
    | rename eai:acl.app as app, eai:acl.sharing as sharing \
    | fields - published id eai* null* \
    | eval stanza = title \
    | fields title author splunk_server app sharing stanza ** \
    | eval author = if(author="nobody", "system", author) , title="[".title."]" \
    | foreach * \
        [ eval title = if("<<FIELD>>"="author" OR "<<FIELD>>"="splunk_server" OR "<<FIELD>>"="app" OR "<<FIELD>>"="sharing" OR "<<FIELD>>"="title" OR "<<FIELD>>"="stanza" OR '<<FIELD>>'="", title, mvappend (title, "<<FIELD>>"." = ".'<<FIELD>>'." "))] \
    | rename splunk_server AS Splunk_Instance \
    | eval title=mvjoin(title, "###") , config_file="web.conf" \
    | fields Splunk_Instance config_file app sharing author stanza title updated\
        ] \
| append \
    [| rest /servicesNS/-/-/configs/conf-ui-prefs splunk_server_group="*" timeout=0 \
    | rename eai:acl.app as app, eai:acl.sharing as sharing \
    | fields - published id eai* null* \
    | eval stanza = title \
    | fields title author splunk_server app sharing stanza ** \
    | eval author = if(author="nobody", "system", author) , title="[".title."]" \
    | foreach * \
        [ eval title = if("<<FIELD>>"="author" OR "<<FIELD>>"="splunk_server" OR "<<FIELD>>"="app" OR "<<FIELD>>"="sharing" OR "<<FIELD>>"="title" OR "<<FIELD>>"="stanza" OR '<<FIELD>>'="", title, mvappend (title, "<<FIELD>>"." = ".'<<FIELD>>'." "))] \
    | rename splunk_server AS Splunk_Instance \
    | eval title=mvjoin(title, "###") , config_file="ui-prefs.conf" \
    | fields Splunk_Instance config_file app sharing author stanza title updated\
        ] \
| append \
    [| rest /servicesNS/-/-/configs/conf-props splunk_server_group="*" timeout=0 \
    | rename eai:acl.app as app, eai:acl.sharing as sharing \
    | fields - published id eai* null* \
    | eval stanza = title \
    | fields title author splunk_server app sharing stanza ** \
    | eval author = if(author="nobody", "system", author) , title="[".title."]" \
    | foreach * \
        [ eval title = if("<<FIELD>>"="author" OR "<<FIELD>>"="splunk_server" OR "<<FIELD>>"="app" OR "<<FIELD>>"="sharing" OR "<<FIELD>>"="title" OR "<<FIELD>>"="stanza" OR '<<FIELD>>'="", title, mvappend (title, "<<FIELD>>"." = ".'<<FIELD>>'." "))] \
    | rename splunk_server AS Splunk_Instance \
    | eval title=mvjoin(title, "###") , config_file="props.conf" \
    | fields Splunk_Instance config_file app sharing author stanza title updated\
        ] \
| append \
    [| rest /servicesNS/-/-/configs/conf-transforms splunk_server_group="*" timeout=0 \
    | rename eai:acl.app as app, eai:acl.sharing as sharing \
    | fields - published id eai* null* \
    | eval stanza = title \
    | fields title author splunk_server app sharing stanza ** \
    | eval author = if(author="nobody", "system", author) , title="[".title."]" \
    | foreach * \
        [ eval title = if("<<FIELD>>"="author" OR "<<FIELD>>"="splunk_server" OR "<<FIELD>>"="app" OR "<<FIELD>>"="sharing" OR "<<FIELD>>"="title" OR "<<FIELD>>"="stanza" OR '<<FIELD>>'="", title, mvappend (title, "<<FIELD>>"." = ".'<<FIELD>>'." "))] \
    | rename splunk_server AS Splunk_Instance \
    | eval title=mvjoin(title, "###") , config_file="transforms.conf" \
    | fields Splunk_Instance config_file app sharing author stanza title updated\
        ] \
| `strptime_format(updated)` \
| eval Splunk_Instance = lower(Splunk_Instance) \
| table Splunk_Instance config_file app sharing author stanza title updated \
| outputlookup splunk_rest_configs_conf_files_all_kv_store_lookup createinapp=true create_empty=true override_if_empty=false\
| stats count

[splunk_identities_custom_sh_csv_lookup_gen]
dispatch.earliest_time = -60m@m
dispatch.latest_time = now
search = index=oswinsec \
| rename User AS identity `gmc_comment("<--rename all your custom identities fields here, after prepping all the fields uncomment the outputlookup command below")` \
| table identity,prefix,suffix,nick,first,last,emp_name,emp_ttl,emp_dep,emp_lob,emp_cc,email,work_city,work_region,work_country,emp_type,emp_status,phone,phone2,managedBy,priority,bunit,startDate,endDate,emp_loc,emp_floor,emp_tz,work_lat,work_long \
| eval email=lower(email)\
| sort 0 identity\
| `gmc_comment("| outputlookup splunk_identities_custom_sh_csv_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count")`

[splunk_rest_data_index_volumes_idx_kv_store_lookup_gen]
allow_skew = 0
cron_schedule = 40 3 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
run_on_startup = 0
schedule_window = 0
search = | rest /services/data/index-volumes splunk_server_group=dmc_group_indexer timeout=0 \
| rename splunk_server AS Splunk_Instance \
| fields title max_size Splunk_Instance total_size volume_path \
| `get_idxcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| stats \
    values(Splunk_Instance) AS Splunk_Instance\
    last(*) as * \
    by idxcluster_label title \
| table idxcluster_label Splunk_Instance title max_size total_size volume_path \
| outputlookup splunk_rest_data_index_volumes_idx_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_data_inputs_all_kv_store_lookup_gen]
allow_skew = 0
cron_schedule = 50 3 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
run_on_startup = 0
schedule_window = 0
search = | rest /servicesNS/-/-/data/inputs/all splunk_server_group="*" timeout=0 \
| rename "eai:acl.*" as "*", "eai:*" as "*" , splunk_server AS Splunk_Instance \
| where type!="ssl" \
| eval author = if(author="nobody", "system", author) \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| eval index=if(index="default", "main", index) \
| fields shcluster_label Splunk_Instance disabled app sharing author type title description source sourcetype index location acceleration whitelist blacklist crcSalt interval updated \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    last(*) as * \
    by shcluster_label app title \
| table shcluster_label Splunk_Instance app title disabled sharing author type description source sourcetype index location acceleration whitelist blacklist crcSalt interval updated \
| outputlookup splunk_rest_data_inputs_all_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_identities_custom_sh_csv_gap_lookup_gen]
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | from lookup:splunk_identities_kv_store_lookup \
| fields identity,prefix,nick,first,last,suffix,email,phone,phone2,managedBy,priority,bunit,category,watchlist,startDate,endDate,work_city,work_country,work_lat,work_long,work_region,emp_cc,emp_dep,emp_floor,emp_lob,emp_loc,emp_name,emp_status,emp_ttl,emp_type,emp_tz,Splunk_Instance \
| search NOT \
    [| inputlookup splunk_identities_custom_sh_csv_lookup \
    | fields identity] \
| table identity,prefix,suffix,nick,first,last,emp_name,emp_ttl,emp_dep,emp_lob,emp_cc,email,work_city,work_region,work_country,emp_type,emp_status,phone,phone2,managedBy,priority,bunit,startDate,endDate,emp_loc,emp_floor,emp_tz,work_lat,work_long \
| outputlookup splunk_identities_custom_sh_csv_lookup append=t

[splunk_index_internal_scheduler_jobs_tracker_sh_kv_store_lookup_tracker]
allow_skew = 25%
cron_schedule = 3-58/5 * * * *
dispatch.earliest_time = -10m@m
dispatch.latest_time = -5m@m
enableSched = 1
schedule_window = 0
search = index=_internal sourcetype=scheduler search_group=dmc_group_search_head status=completed search_type!=datamodel_acceleration app!=splunk_archiver \
| fields _time host savedsearch_name app user scheduled_time priority dispatch_time window_time run_time result_count search_group \
| rename host as Splunk_Instance , savedsearch_name as Savedsearch_Name , app as App , user as User , scheduled_time as Scheduled_Time , priority as Priority, dispatch_time as Dispatch_Time, window_time as Window_Time , run_time as Run_Time, result_count as Result_Count \
| eval User = lower(User) , Splunk_Instance = lower(Splunk_Instance) , User = if(User="nobody", "system", User) \
| `get_instance_roles(Splunk_Instance)` \
| `get_shcluster_label(Splunk_Instance)` \
| fields - search_group \
| eval locator=md5(Splunk_Instance + Savedsearch_Name) \
| stats \
    earliest(_time) AS Earliest_Access \
    latest(_time) AS Latest_Access \
    values(Splunk_Instance) AS Splunk_Instance \
    values(shcluster_label) AS shcluster_label \
    latest(*) AS * \
    BY locator \
| table locator shcluster_label Splunk_Instance Savedsearch_Name App User Scheduled_Time Priority Dispatch_Time Window_Time Earliest_Access Latest_Access Run_Time Result_Count \
| outputlookup splunk_index_internal_scheduler_jobs_tracker_sh_kv_store_lookup key_field=locator createinapp=true \
| stats count

[splunk_internal_index_license_usage_idx_summary_tracker]
cron_schedule = 10 1 * * *
description = Total License Usage By Cluster By Index Daily Tracker
dispatch.earliest_time = -1s@s
dispatch.latest_time = now
enableSched = 1
realtime_schedule = 0
schedule_priority = highest
schedule_window = 0
search = index=_internal sourcetype=splunkd component=LicenseUsage type=Usage `license_master` earliest=-5d@d latest=-0d@d \
| rename i AS Indexer_GUID idx AS Index_Name h AS Lic_Host s AS Lic_Source st AS Lic_Sourcetype b AS License_Usage o AS Lic_O pool AS Lic_Pool poolsz AS Lic_Pool_Size \
| fields _time Indexer_GUID Index_Name Lic_Host Lic_Source Lic_O Lic_Sourcetype License_Usage Lic_Pool Lic_Pool_Size \
| eval\
    Lic_Host = if(len(Lic_Host)=0 OR isnull(Lic_Host), "(SQUASHED)", Lic_Host),\
    Lic_Source = if(len(Lic_Source)=0 OR isnull(Lic_Source), "(SQUASHED)", Lic_Source), \
    Index_Name = if(len(Index_Name)=0 OR isnull(Index_Name), "(UNKNOWN)", Index_Name),\
    Index_Name=if(Index_Name="default", "main", Index_Name) \
| `get_idxcluster_label_guid(Indexer_GUID)` \
| bin _time span=1d \
| stats \
    latest(Lic_Pool_Size) AS Lic_Pool_Size\
    sum(License_Usage) AS License_Usage\
    BY _time idxcluster_label Lic_Pool Lic_Source Lic_Sourcetype Lic_Host Index_Name \
| stats \
    values(Lic_Source) AS Lic_Source\
    values(Lic_Host) AS Lic_Host\
    latest(Lic_Pool_Size) AS Lic_Pool_Size\
    sum(License_Usage) AS License_Usage\
    BY _time idxcluster_label Lic_Pool Index_Name Lic_Sourcetype \
| join type=outer _time \
    [ search index=_internal sourcetype=splunkd component=LicenseUsage `license_master` type="RolloverSummary" earliest=-30d@d \
    | eval _time=_time - 43200 \
    | bin _time span=1d \
    | dedup _time stack \
    | stats sum(stacksz) AS Lic_Stack_Size by _time \
    | fields Lic_Stack_Size] \
| eval time=_time \
| search NOT \
    [ search index=`gmc_summary_index` search_name="splunk_internal_index_license_usage_idx_summary_tracker" earliest=-6d@d \
    | bin _time span=1d \
    | eval time=_time \
    | fields time ] \
| eval type="Usage" ,search_name="splunk_internal_index_license_usage_idx_summary_tracker" \
| fields _time search_name idxcluster_label Lic_Pool Lic_Pool_Size Lic_Stack_Size type Index_Name Lic_Sourcetype Lic_Source Lic_Host License_Usage \
| sort 0 - _time \
| collect index=`gmc_summary_index` `gmc_comment("testmode=true")` \
| stats count

[splunk_index_internal_scheduler_jobs_tracker_sh_kv_store_lookup_restore_gen]
allow_skew = 0
dispatch.earliest_time = -1s
dispatch.latest_time = now
schedule_window = 0
search = | inputlookup splunk_index_internal_scheduler_jobs_tracker_sh_kv_store_lookup_backup.csv \
| makemv delim="|" Login_Source \
| makemv delim="|" Splunk_Instance \
| eval Splunk_Instance=lower(trim(Splunk_Instance)) , User=lower(trim(User)) \
| eval locator=md5(Splunk_Instance + Savedsearch_Name) \
| stats latest(_time) as Latest_Access \
    values(Splunk_Instance) AS Splunk_Instance\
    last(*) AS * \
    BY locator \
| table locator shcluster_label Splunk_Instance Savedsearch_Name App User Scheduled_Time Priority Dispatch_Time Window_Time Earliest_Access Latest_Access Run_Time Result_Count \
| `gmc_comment("| outputlookup splunk_index_internal_scheduler_jobs_tracker_sh_kv_store_lookup key_field=locator createinapp=true")`

[splunk_rest_data_indexes_idx_kv_store_lookup_gen]
allow_skew = 0
cron_schedule = 30 5 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
run_on_startup = 0
schedule_window = 0
search = | rest /services/data/indexes-extended Splunk_Server_Group=dmc_group_indexer Timeout=0 \
| rename "eai:acl.*" as "*", "eai:*" as "*" , splunk_server AS Splunk_Instance \
| search NOT title IN (_thefishbucket, splunklogger) \
| fields Splunk_Instance title app coldPath coldPath.maxDataSizeMB coldToFrozenDir coldToFrozenScript currentDBSizeMB datamodel_summary_size datatype frozenTimePeriodInSecs homePath homePath.maxDataSizeMB isInternal maxDataSize maxGlobalDataSizeMB maxGlobalRawDataSizeMB maxHotBuckets maxHotIdleSecs maxHotSpanSecs maxTime maxTotalDataSizeMB maxWarmDBCount minHotIdleSecsBeforeForceRoll minTime quarantineFutureSecs quarantinePastSecs repFactor rotatePeriodInSecs thawedPath throttleCheckPeriod totalEventCount total_bucket_count total_capacity total_raw_size tstatsHomePath disabled updated bucket_dirs.* \
| `get_idxcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| eval author = if(author="nobody", "system", author), minTime=strptime(minTime,"%Y-%m-%dT%H:%M:%S") , maxTime=strptime(maxTime,"%Y-%m-%dT%H:%M:%S") \
| stats \
    Sum(currentDBSizeMB) as currentDBSizeMB\
    Sum(eval(currentDBSizeMB *1024 * 1024)) as currentDBSize\
    Sum(total_raw_size) AS total_raw_size\
    Sum(totalEventCount) as totalEventCount min(minTime) as minTime max(maxTime) as maxTime\
    Sum(datamodel_summary_size) AS datamodel_summary_size\
    Sum(bucket_dirs.cold.bucket_size) as cold_bucket_size\
    Sum(bucket_dirs.home.warm_bucket_size) as warm_bucket_size\
    Values(Splunk_Instance) AS Splunk_Instance\
    Avg(total_bucket_count) AS total_bucket_count_avg\
    Values(app) AS app\
    Last(isInternal) AS isInternal\
    Last(maxTotalDataSizeMB) as maxTotalDataSizeMB\
    Last(frozenTimePeriodInSecs) as frozenTimePeriodInSecs\
    Last(quarantineFutureSecs) as quarantineFutureSecs\
    Last(quarantinePastSecs) as quarantinePastSecs\
    Last(maxHotSpanSecs) as maxHotSpanSecs\
    Last(coldPath.maxDataSizeMB) AS coldPath_maxDataSizeMB\
    Last(homePath.maxDataSizeMB) AS homePath_maxDataSizeMB\
    Last(coldPath) AS coldPath\
    Last(coldToFrozenDir) AS coldToFrozenDir\
    Last(coldToFrozenScript) AS coldToFrozenScript\
    Last(datatype) AS datatype\
    Last(homePath) AS homePath\
    Last(maxDataSize) AS maxDataSize\
    Last(maxGlobalDataSizeMB) AS maxGlobalDataSizeMB\
    Last(maxGlobalRawDataSizeMB) AS maxGlobalRawDataSizeMB\
    Last(maxHotBuckets) AS maxHotBuckets\
    Last(maxHotIdleSecs) AS maxHotIdleSecs\
    Last(maxWarmDBCount) AS maxWarmDBCount\
    Last(minHotIdleSecsBeforeForceRoll) AS minHotIdleSecsBeforeForceRoll\
    Last(repFactor) AS repFactor\
    Last(rotatePeriodInSecs) AS rotatePeriodInSecs\
    Last(thawedPath) AS thawedPath\
    Last(throttleCheckPeriod) AS throttleCheckPeriod \
    Last(total_capacity) AS total_capacity\
    Last(tstatsHomePath) AS tstatsHomePath\
    Last(disabled) AS disabled\
    Last(updated) AS updated\
    by idxcluster_label title \
| table idxcluster_label Splunk_Instance title app coldPath coldPath_maxDataSizeMB coldToFrozenDir coldToFrozenScript currentDBSize currentDBSizeMB datamodel_summary_size datatype frozenTimePeriodInSecs homePath homePath_maxDataSizeMB isInternal maxDataSize maxGlobalDataSizeMB maxGlobalRawDataSizeMB maxHotBuckets maxHotIdleSecs maxHotSpanSecs maxTime maxTotalDataSizeMB maxWarmDBCount minHotIdleSecsBeforeForceRoll minTime quarantineFutureSecs quarantinePastSecs repFactor rotatePeriodInSecs thawedPath throttleCheckPeriod totalEventCount total_bucket_count_avg total_capacity total_raw_size tstatsHomePath disabled updated cold_bucket_size warm_bucket_size \
| outputlookup splunk_rest_data_indexes_idx_kv_store_lookup CreateInApp=true Create_Empty=true Override_If_Empty=false \
| stats count

[GeoLite2-City-Locations-en_with_lat_lon_lookup_gen]
search = | inputlookup GeoLite2-City-Locations-en.csv \
| fields geoname_id,locale_code,continent_code,continent_name,country_iso_code,country_name,subdivision_1_iso_code,subdivision_1_name,subdivision_2_iso_code,subdivision_2_name,city_name,metro_code,time_zone,is_in_european_union \
| table geoname_id city_name country_iso_code country_name subdivision_1_iso_code subdivision_1_name continent_code continent_name time_zone is_in_european_union \
| lookup GeoLite2-City-Blocks-IPv4_Deduped.csv geoname_id OUTPUT registered_country_geoname_id latitude longitude \
| lookup GeoLite2-City-Blocks-IPv6_Deduped.csv geoname_id OUTPUTNEW registered_country_geoname_id latitude longitude \
| table city_name subdivision_1_name country_name subdivision_1_iso_code country_iso_code continent_code continent_name time_zone is_in_european_union registered_country_geoname_id geoname_id latitude longitude \
| where isnotnull(longitude) \
| rename city_name as city country_name as country subdivision_1_name as region \
| fields country region city region_code country_iso2 country_iso3 subregion latitude longitude \
| stats last(*) as * by country region city \
| sort 0 city_name subdivision_1_name country_name \
`gmc_comment("| outputlookup GeoLite2-City-Locations-en_Enhanced.csv")`

[splunk_rest_admin_search_concurrency_settings_handler_sh_kv_store_lookup_gen]
cron_schedule = 40 2 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
run_on_startup = 0
search = | rest /servicesNS/-/-/admin/search-concurrency-settings-handler splunk_server_group="dmc_group_search_head" timeout=0 \
| rename splunk_server As Splunk_Instance \
| fields Splunk_Instance title auto_summary_perc base_max_searches max_rt_search_multiplier max_searches_per_cpu max_searches_perc \
 `gmc_comment("| join Splunk_Instance \
    [| rest /servicesNS/-/-/admin/server-status-limits-concurrency splunk_server_group="dmc_group_search_head" timeout=0 \
    | fields splunk_server max_auto_summary_searches max_hist_scheduled_searches max_hist_searches max_rt_scheduled_searches max_rt_searches \
    | rename splunk_server AS Splunk_Instance ]")` \
| join Splunk_Instance \
    [| rest "/services/server/status/limits/search-concurrency?cluster_wide_quota=1" splunk_server_group="dmc_group_search_head" timeout=0 \
    | rename "eai:acl.*" As "*", "eai:*" As "*", splunk_server As Splunk_Instance \
    | fields Splunk_Instance title max_auto_summary_searches max_hist_scheduled_searches max_hist_searches max_rt_scheduled_searches max_rt_searches] \
| `get_shcluster_label(Splunk_Instance)` \
| stats \
    Values(Splunk_Instance) As Splunk_Instance\
    Last(*) As * \
    By shcluster_label title \
| table shcluster_label Splunk_Instance title auto_summary_perc base_max_searches max_rt_search_multiplier max_searches_per_cpu max_searches_perc max_auto_summary_searches max_hist_scheduled_searches max_hist_searches max_rt_scheduled_searches max_rt_searches \
| outputlookup splunk_rest_admin_search_concurrency_settings_handler_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[Report_on_highest_number_of_events_by_sourcetype_enriched_with_sourcetype_metadata]
dispatch.earliest_time = -5m
dispatch.latest_time = now
search = | metadata type=sourcetypes index=* \
| `get_sourcetype_info(sourcetype)` \
| table sourcetype totalCount app sharing LINE_BREAKER EVENT_BREAKER_ENABLE EVENT_BREAKER firstTime lastTime recentTime \
| sort 0 - totalCount

[splunk_rest_configs_conf_props_sh_kv_store_lookup_gen]
cron_schedule = 30 3 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
run_on_startup = 0
search = | rest /servicesNS/-/-/configs/conf-props splunk_server_group="*" timeout=0 \
| rename "eai:acl.*" as "*" , "eai:*" AS "*" , splunk_server AS Splunk_Instance \
| where app!="learned"\
| eval author = if(author="nobody", "system", author) \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| fields shcluster_label Splunk_Instance title app sharing author description TIME_PREFIX TIME_FORMAT MAX_TIMESTAMP_LOOKAHEAD DATETIME_CONFIG SHOULD_LINEMERGE LINE_BREAKER TRUNCATE BREAK_ONLY_BEFORE BREAK_ONLY_BEFORE_DATE MUST_BREAK_AFTER KV_MODE INDEXED_EXTRACTIONS EVENT_BREAKER_ENABLE EVENT_BREAKER ANNOTATE_PUNCT LEARN_SOURCETYPE LEARN_MODEL MAX_EVENTS maxDist updated sourcetype \
| eval title=if(isnotnull(sourcetype) AND sourcetype!="", sourcetype, title) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    last(*) as * \
    BY shcluster_label app title \
| table shcluster_label Splunk_Instance title app sharing author description TIME_PREFIX TIME_FORMAT MAX_TIMESTAMP_LOOKAHEAD DATETIME_CONFIG SHOULD_LINEMERGE LINE_BREAKER TRUNCATE BREAK_ONLY_BEFORE BREAK_ONLY_BEFORE_DATE MUST_BREAK_AFTER KV_MODE INDEXED_EXTRACTIONS EVENT_BREAKER_ENABLE EVENT_BREAKER ANNOTATE_PUNCT LEARN_SOURCETYPE LEARN_MODEL MAX_EVENTS maxDist updated \
| outputlookup splunk_rest_configs_conf_props_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_index_audit_user_login_tracker_sh_kv_store_lookup_tracker]
allow_skew = 25%
cron_schedule = 1-56/5 * * * *
dispatch.earliest_time = -10m@m
dispatch.latest_time = -5m@m
enableSched = 1
search = ((index=_audit sourcetype=audittrail) AND (user=* "action=login attempt" info=succeeded)) \
    OR (search_group IN (dmc_group_search_head,dmc_group_cluster_master,dmc_group_deployment_server,dmc_group_shc_eployer,dmc_group_license_master) user=* NOT user IN ("n/a",splunk-system-user) action=search info=granted search_id!="rsa_*" search=*) \
    OR (index=_internal sourcetype=splunkd_ui_access useragent=* status=200 user!="-") \
| eval search_type = if(match(search_id, "\d{10}\.\d+(_[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12})?$"), "adhoc", "other") \
| search info="succeeded" OR search_type="adhoc" OR (index=_internal sourcetype=splunkd_ui_access useragent=* status=200 user!="-") \
| rex field=useragent "(?<Browser_and_Version>(MSIE|Trident|(?!Gecko.+)Firefox|(?!AppleWebKit.+Chrome.+)Safari(?!.+Edge)|(?!AppleWebKit.+)Chrome(?!.+Edge)|(?!AppleWebKit.+Chrome.+Safari.+)Edge|AppleWebKit(?!.+Chrome|.+Safari)|Gecko(?!.+Firefox))(?: |\/)([\d\.apre]+)|Splunk.*?\s)" \
| rex field=useragent "(Version/|iPhone\sOS\s)(?<Safari_Version>.*?)\s" \
| rex field=Browser_and_Version "(?<Browser_Name>.*?)/" \
| rex field=Browser_and_Version "/(?<Browser_Version>.*?)$" \
| rex field=useragent "(?<Architecture>(Win64|x86_64))" \
| rex field=useragent "(?<OS_Name>(Linux|Macintosh|Windows\s*\w+|iPhone|iPad))" \
| rex field=useragent "(Linux\s|Macintosh;\s|i\w+;\s|Windows\sNT\s)(?<OS_Version>.*?)[;)]" \
| eval \
    Browser_Version = if(isnotnull(Safari_Version), Safari_Version, Browser_Version), \
    Browser_Name=if(Browser_Name="Trident", "Internet Explorer", Browser_Name), \
    OS_Name = case ( \
    match(useragent,"Windows NT 6.1"), "Windows 7", \
    match(useragent,"Windows NT 6.2"), "Windows 8", \
    match(useragent,"Windows NT 6.3"), "Windows 8.1", \
    match(useragent,"Windows NT 10.0"), "Windows 10", \
    match(useragent,"Pixel"), "Google Pixel",\
    match(useragent,"Android"), "Android", \
    true(), OS_Name ) , \
    Splunk_Instance = trim(lower(host)) ,\
    Login_Source = lower(src) , \
    Login_Source=mvsort(mvdedup((mvappend(Login_Source, clientip)))),\
    locator=md5(lower(user)) \
| fields _time locator user Login_Source Splunk_Instance OS_Name OS_Version Browser_Name Browser_Version \
| lookup splunk_index_audit_user_login_tracker_sh_kv_store_lookup User AS user OUTPUT Splunk_Instance AS Splunk_Instance_KV Login_Source AS Login_Source_KV \
| stats \
    earliest(_time) as Earliest_Access \
    latest(_time) as Latest_Access \
    values(Splunk_Instance) as Splunk_Instance values(Splunk_Instance_KV) as Splunk_Instance_KV \
    values(Login_Source) as Login_Source values(Login_Source_KV) as Login_Source_KV \
    values(OS_Name) as OS_Name\
    values(OS_Version) as OS_Version\
    values(Browser_Name) as Browser_Name\
    values(Browser_Version) as Browser_Version\
    latest(user) as User \
    BY locator \
| eval \
    Splunk_Instance = mvfilter ( !match (Splunk_Instance,"none") ),\
    Login_Source = mvfilter ( !match (Login_Source,"127.0.0.1|authentication|src") ),\
    OS_Name = mvfilter ( !match (OS_Name,"^case") ) ,\
    Browser_Version = mvfilter ( !match (Browser_Version,"^if") ) \
    `gmc_comment(", Login_Source = mvindex ( Login_Source, 0, 4 ) ")` \
| foreach Login_Source Splunk_Instance OS_Name OS_Version Browser_Name Browser_Version \
    [ eval <<FIELD>>=mvsort(mvdedup('<<FIELD>>'))] \
| table locator User Earliest_Access Latest_Access Login_Source Splunk_Instance OS_Name OS_Version Browser_Name Browser_Version \
| outputlookup splunk_index_audit_user_login_tracker_sh_kv_store_lookup key_field=locator createinapp=true \
| stats count

[splunk_index_audit_user_login_tracker_sh_kv_store_lookup_restore_gen]
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | inputlookup splunk_index_audit_user_login_tracker_sh_kv_store_lookup_backup.csv \
| fields User Earliest_Access Latest_Access Login_Source Splunk_Instance OS_Name OS_Version Browser_Name Browser_Version \
| makemv delim="," Login_Source \
| makemv delim="," Splunk_Instance \
| makemv delim="," OS_Name \
| makemv delim="," OS_Version \
| makemv delim="," Browser_Name \
| makemv delim="," Browser_Version \
| eval locator=md5(lower(User)) \
| stats \
    last(Earliest_Access) as Earliest_Access \
    last(Latest_Access) as Latest_Access \
    values(Splunk_Instance) as Splunk_Instance\
    values(Login_Source) as Login_Source \
    values(OS_Name) as OS_Name\
    values(OS_Version) as OS_Version\
    values(Browser_Name) as Browser_Name\
    values(Browser_Version) as Browser_Version\
    last(User) as User \
    BY locator \
| table locator User Earliest_Access Latest_Access Login_Source Splunk_Instance OS_Name OS_Version Browser_Name Browser_Version \
    `gmc_comment("| outputlookup splunk_index_audit_user_login_tracker_sh_kv_store_lookup key_field=locator createinapp=true")`

[splunk_index_audit_user_login_tracker_sh_kv_store_lookup_backup_gen]
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | from lookup: splunk_index_audit_user_login_tracker_sh_kv_store_lookup \
| fields User Earliest_Access Latest_Access Login_Source Splunk_Instance OS_Name OS_Version Browser_Name Browser_Version \
| eval locator=md5(lower(User)) \
| stats \
    last(Earliest_Access) as Earliest_Access \
    last(Latest_Access) as Latest_Access \
    values(Splunk_Instance) as Splunk_Instance\
    values(Login_Source) as Login_Source \
    values(OS_Name) as OS_Name\
    values(OS_Version) as OS_Version\
    values(Browser_Name) as Browser_Name\
    values(Browser_Version) as Browser_Version\
    last(User) as User \
    BY locator \
| eval \
    OS_Name = mvfilter ( !match (OS_Name,"^case") ) ,\
    Browser_Version = mvfilter ( !match (Browser_Version,"^if") ) \
| foreach Login_Source Splunk_Instance OS_Name OS_Version Browser_Name Browser_Version \
    [ eval <<FIELD>>=mvsort(mvdedup('<<FIELD>>'))] \
| eval \
    Login_Source=mvjoin(mvdedup(Login_Source), ","), \
    Splunk_Instance=mvjoin(mvdedup(Splunk_Instance),","),\
    OS_Name=mvjoin(mvdedup(OS_Name),","), \
    OS_Version=mvjoin(mvdedup(OS_Version),","),\
    Browser_Name=mvjoin(mvdedup(Browser_Name),","),\
    Browser_Version=mvjoin(mvdedup(Browser_Version),",") \
| table locator User Earliest_Access Latest_Access Login_Source Splunk_Instance OS_Name OS_Version Browser_Name Browser_Version \
    `gmc_comment("| outputlookup splunk_index_audit_user_login_tracker_sh_kv_store_lookup_backup.csv")`

[splunk_index_internal_scheduler_jobs_tracker_sh_kv_store_lookup_backup_gen]
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | inputlookup splunk_index_internal_scheduler_jobs_tracker_sh_kv_store_lookup \
| fields shcluster_label Splunk_Instance Savedsearch_Name App User Scheduled_Time Priority Dispatch_Time Window_Time Earliest_Access Latest_Access Run_Time Result_Count \
| eval locator=md5(Splunk_Instance + Savedsearch_Name) \
| stats \
    last(Earliest_Access) AS Earliest_Access \
    last(Latest_Access) AS Latest_Access \
    values(shcluster_label) AS shcluster_label \
    values(Splunk_Instance) AS Splunk_Instance \
    last(*) As *\
    BY locator \
| eval Splunk_Instance=mvjoin(mvdedup(Splunk_Instance),",") \
| table locator shcluster_label Splunk_Instance Savedsearch_Name App User Scheduled_Time Priority Dispatch_Time Window_Time Earliest_Access Latest_Access Run_Time Result_Count \
| `gmc_comment("| outputlookup splunk_index_internal_scheduler_jobs_tracker_sh_kv_store_lookup_backup.csv")`

[splunk_internal_forwarder_stats_idx_summary_tracker]
cron_schedule = 50 5 * * *
dispatch.earliest_time = -2d@h
dispatch.latest_time = -0d@d
enableSched = 1
run_on_startup = 0
schedule_window = auto
search = index=_internal sourcetype=splunkd search_group=dmc_group_indexer fwdType=* group=tcpin_connections guid=* connectionType IN (cooked, cookedSSL) earliest=-2d@d latest=-0d@d \
| fields _time ack arch chan_new_kBps connectionType destPort evt_fields_kBps evt_fn_kBps evt_fn_meta_dyn_kBps evt_fn_meta_predef_kBps evt_fn_meta_str_kBps evt_fn_str_kBps evt_fv_fp_kBps evt_fv_kBps evt_fv_num_kBps evt_fv_offlen_kBps evt_fv_predef_kBps evt_fv_str_kBps evt_misc_kBps evt_raw_kBps fwdType guid host hostname ingest_pipe kb lastIndexer os process_time_ms sourceHost sourceIp sourcePort ssl tcp_avg_thruput tcp_Bps tcp_eps tcp_KBps tcp_Kprocessed udp_avg_thruput udp_Bps udp_eps udp_KBps udp_Kprocessed tz_kBps version \
| bucket _time span=1d \
| `get_idxcluster_label(host)` \
| stats \
    Avg(chan_new_kBps) AS chan_new_kBps\
    Avg(evt_fields_kBps) AS evt_fields_kBps\
    Avg(evt_fn_kBps) AS evt_fn_kBps\
    Avg(evt_fn_meta_dyn_kBps) AS evt_fn_meta_dyn_kBps\
    Avg(evt_fn_meta_predef_kBps) AS evt_fn_meta_predef_kBps\
    Avg(evt_fn_meta_str_kBps) AS evt_fn_meta_str_kBps\
    Avg(evt_fn_str_kBps) AS evt_fn_str_kBps\
    Avg(evt_fv_fp_kBps) AS evt_fv_fp_kBps\
    Avg(evt_fv_kBps) AS evt_fv_kBps\
    Avg(evt_fv_num_kBps) AS evt_fv_num_kBps\
    Avg(evt_fv_offlen_kBps) AS evt_fv_offlen_kBps\
    Avg(evt_fv_predef_kBps) AS evt_fv_predef_kBps\
    Avg(evt_fv_str_kBps) AS evt_fv_str_kBps\
    Avg(evt_misc_kBps) AS evt_misc_kBps\
    Avg(evt_raw_kBps) AS evt_raw_kBps\
    Avg(process_time_ms) AS process_time_ms\
    Avg(tcp_avg_thruput) AS tcp_avg_thruput\
    Avg(tcp_Bps) AS tcp_Bps\
    Avg(tcp_eps) AS tcp_eps\
    Avg(tcp_KBps) AS tcp_KBps\
    Avg(tcp_Kprocessed) AS tcp_Kprocessed\
    Avg(tz_kBps) AS tz_kBps\
    Avg(udp_avg_thruput) AS udp_avg_thruput\
    Avg(udp_Bps) AS udp_Bps\
    Avg(udp_eps) AS udp_eps\
    Avg(udp_KBps) AS udp_KBps\
    Avg(udp_Kprocessed) AS udp_Kprocessed\
    Latest(ack) AS ack\
    Latest(arch) AS arch\
    Latest(connectionType) AS connectionType\
    Latest(fwdType) AS fwdType\
    Latest(guid) AS guid\
    Latest(os) AS os\
    Latest(sourceHost) AS sourceHost\
    Latest(sourceIp) AS sourceIp\
    Latest(sourcePort) AS sourcePort\
    Latest(ssl) AS ssl\
    Latest(version) AS version\
    Values(ingest_pipe) AS ingest_pipe\
    Values(lastIndexer) AS lastIndexer\
    Values(destPort) AS destPort\
    Values(host) AS Indexers\
    Sum(kb) AS kb\
    by _time idxcluster_label hostname \
| eval time=_time \
| search NOT \
    [ search index=`gmc_summary_index` search_name="splunk_internal_forwarder_stats_idx_summary_tracker" earliest=-3d@d latest=-0d@d \
    | bin _time span=1d \
    | eval time=_time \
    | fields time] \
| eval \
    search_name="splunk_internal_forwarder_stats_idx_summary_tracker",\
    lastIndexer=mvfilter ( ! match (lastIndexer,"None") ),\
    lastIndexer=mvjoin(lastIndexer, ","),\
    ingest_pipe=mvjoin(ingest_pipe, ","),\
    destPort=mvjoin(destPort, ","),\
    Indexers=mvjoin(Indexers, ",")\
| sort 0 - _time \
| fields _time search_name idxcluster_label Indexers hostname sourceHost sourceIp ack arch chan_new_kBps connectionType destPort evt_fields_kBps evt_fn_kBps evt_fn_meta_dyn_kBps evt_fn_meta_predef_kBps evt_fn_meta_str_kBps evt_fn_str_kBps evt_fv_fp_kBps evt_fv_kBps evt_fv_num_kBps evt_fv_offlen_kBps evt_fv_predef_kBps evt_fv_str_kBps evt_misc_kBps evt_raw_kBps fwdType guid ingest_pipe kb lastIndexer os process_time_ms sourcePort ssl tcp_avg_thruput tcp_Bps tcp_eps tcp_KBps tcp_Kprocessed udp_avg_thruput udp_Bps udp_eps udp_KBps udp_Kprocessed tz_kBps version \
| collect index=`gmc_summary_index` `gmc_comment("testmode=true")` \
| stats count

[splunk_internal_license_rollover_summary_idx_summary_tracker]
cron_schedule = 0 1 * * *
description = Total License Usage By Cluster Daily Tracker
dispatch.earliest_time = -5d@d
dispatch.latest_time = now
enableSched = 1
schedule_window = auto
search = index=_internal sourcetype=splunkd component=LicenseUsage type=RolloverSummary `license_master` earliest=-5d@d latest=now\
| rename slave AS Indexer_GUID b AS License_Usage pool AS Lic_Pool poolsz AS Lic_Pool_Size stacksz AS Lic_Stack_Size \
| `get_idxcluster_label_guid(Indexer_GUID)` \
| eval _time=_time - 43200 \
| bin _time span=1d \
| stats \
    sum(License_Usage) AS License_Usage \
    latest(Lic_Stack_Size) AS Lic_Stack_Size\
    BY _time idxcluster_label Lic_Pool \
| eval time=_time \
| fields _time time search_name idxcluster_label Lic_Pool type Lic_Stack_Size License_Usage \
| search NOT \
    [ search index=`gmc_summary_index` search_name="splunk_internal_license_rollover_summary_idx_summary_tracker" earliest=-6d@d latest=now\
    | bin _time span=1d \
    | eval time=_time \
    | fields time] \
| eval type="RolloverSummary" , search_name="splunk_internal_license_rollover_summary_idx_summary_tracker" \
| fields _time search_name idxcluster_label Lic_Pool type Lic_Stack_Size License_Usage \
| sort 0 - _time \
| collect index=`gmc_summary_index` `gmc_comment("testmode=true")` \
| stats count

[splunk_introspection_index_size_idx_summary_tracker]
cron_schedule = 20 1 * * *
description = Total Index Size By Cluster By Index Daily Tracker
dispatch.earliest_time = -5d@d
dispatch.latest_time = -0d@d
enableSched = 1
schedule_window = auto
search = index=_introspection sourcetype=splunk_disk_objects component=Indexes search_group=dmc_group_indexer earliest=-5d@d latest=-0d@d \
| rename data.* As * name As Index_Name bucket_dirs.home.warm_bucket_size As warm_bucket_size bucket_dirs.cold.bucket_size As cold_bucket_size \
| fields _time host Index_Name warm_bucket_size cold_bucket_size datamodel_summary_size total_size \
| bin _time Span=1d \
| stats \
    Latest(eval(round(total_size * 1024 * 1024,0))) As total_size\
    Latest(eval(round((total_size * 1024 * 1024) - (cold_bucket_size * 1024 * 1024),0))) As home_bucket_size\
    Latest(eval(round(warm_bucket_size * 1024,0))) As warm_bucket_size\
    Latest(eval(round(cold_bucket_size * 1024 * 1024,0))) As cold_bucket_size\
    Latest(eval(round(datamodel_summary_size * 1024 * 1024,0))) As datamodel_summary_size\
    by _time host Index_Name \
| `get_idxcluster_label(host)` \
| stats \
    Sum(total_size) As total_size \
    Sum(home_bucket_size) As home_bucket_size \
    Sum(warm_bucket_size) As warm_bucket_size \
    Sum(cold_bucket_size) As cold_bucket_size \
    Sum(datamodel_summary_size) As datamodel_summary_size \
    by _time idxcluster_label Index_Name \
| fillnull value=0\
| eval time=_time \
| search NOT \
    [ search index=`gmc_summary_index` search_name="splunk_introspection_index_size_idx_summary_tracker" earliest=-6d@d latest=-0d@d \
    | bin _time Span=1d \
    | eval time=_time \
    | fields time] \
| eval search_name="splunk_introspection_index_size_idx_summary_tracker" \
| fields _time search_name idxcluster_label Index_Name total_size home_bucket_size warm_bucket_size cold_bucket_size datamodel_summary_size \
| sort 0 - _time \
| collect index=`gmc_summary_index` `gmc_comment("testmode=true")` \
| stats count

[splunk_introspection_volume_size_idx_summary_tracker]
cron_schedule = 30 1 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
run_on_startup = 0
schedule_window = auto
search = index=_introspection sourcetype=splunk_disk_objects component=Volumes search_group=dmc_group_indexer earliest=-5d@d latest=-0d@d \
| rename data.* AS * name AS Volume max_size AS Volume_Capacity total_size AS Volume_Usage volume_path AS Volume_Path \
| table _time host Volume Volume_Capacity Volume_Usage Volume_Path \
| bin _time span=1d \
| `get_idxcluster_label(host)` \
| stats \
    Latest(eval(round(Volume_Usage * 1024 * 1024,0))) As Volume_Usage\
    Latest(eval(round(Volume_Capacity * 1024 * 1024,0))) As Volume_Capacity\
    Latest(Volume_Path) AS Volume_Path\
    by _time idxcluster_label host Volume \
| eval time=_time \
| search NOT \
    [ search index=`gmc_summary_index` search_name="splunk_introspection_volume_size_idx_summary_tracker" earliest=-6d@d latest=-0d@d \
    | bin _time span=1d \
    | eval time=_time \
    | fields time] \
| eval\
    search_name="splunk_introspection_volume_size_idx_summary_tracker",\
    Volume_Usage = If(IsNull(Volume_Usage) OR Volume_Usage="", 0, Volume_Usage) \
| sort 0 - _time \
| fields _time search_name idxcluster_label host Volume Volume_Path Volume_Capacity Volume_Usage \
| collect index=`gmc_summary_index` `gmc_comment("testmode=true")` \
| stats count

[splunk_index_internal_web_access_tracker_sh_kv_store_lookup_restore_gen]
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | inputlookup splunk_index_internal_web_access_tracker_sh_kv_store_lookup_backup.csv \
| makemv delim="|" Splunk_Instance \
| makemv delim="|" App \
| makemv delim="|" Dashboard_Name \
| makemv delim="|" User \
| eval User = lower(trim(User)) , Splunk_Instance = trim(lower(Splunk_Instance)) \
| eval locator=md5(Splunk_Instance + Dashboard_Name) \
| stats \
    last(Earliest_Access) AS Earliest_Access\
    last(Latest_Access) AS Latest_Access\
    values(User) AS User\
    values(Splunk_Instance) AS Splunk_Instance\
    values(shcluster_label) AS shcluster_label \
    values(App) AS App \
    values(Dashboard_Name) AS Dashboard_Name \
    last(min_spent) AS min_spent\
    last(max_spent) AS max_spent\
    last(avg_spent) AS avg_spent\
    BY locator \
| eval avg_spent = round(avg_spent) \
| table locator shcluster_label Splunk_Instance App Dashboard_Name User Earliest_Access Latest_Access min_spent max_spent avg_spent \
| `gmc_comment("| outputlookup splunk_index_internal_web_access_tracker_sh_kv_store_lookup key_field=locator createinapp=true")`

[splunk_rest_authorization_roles_sh_kv_store_lookup_gen]
cron_schedule = 20 3 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
search = | rest /servicesNS/-/-/authorization/roles splunk_server_group=dmc_group_search_head timeout=0 \
| rename "eai:acl.*" as "*", "eai:*" as "*" \
| fields splunk_server,title,cumulativeRTSrchJobsQuota,capabilities,imported_capabilities,cumulativeSrchJobsQuota,defaultApp,deleteIndexesAllowed,federatedProviders,grantable_roles,imported_roles,imported_rtSrchJobsQuota,imported_srchDiskQuota,imported_srchFilter,imported_srchIndexesAllowed,imported_srchIndexesDefault,imported_srchJobsQuota,imported_srchTimeWin,rtSrchJobsQuota,srchDiskQuota,srchFilter,srchIndexesAllowed,srchIndexesDefault,srchJobsQuota,srchTimeWin \
| rename splunk_server AS Splunk_Instance \
| `get_shcluster_label(Splunk_Instance)` \
| stats \
    values(*) AS *\
    BY shcluster_label title \
| table shcluster_label,Splunk_Instance,title,cumulativeRTSrchJobsQuota,capabilities,imported_capabilities,cumulativeSrchJobsQuota,defaultApp,deleteIndexesAllowed,federatedProviders,grantable_roles,imported_roles,imported_rtSrchJobsQuota,imported_srchDiskQuota,imported_srchFilter,imported_srchIndexesAllowed,imported_srchIndexesDefault,imported_srchJobsQuota,imported_srchTimeWin,rtSrchJobsQuota,srchDiskQuota,srchFilter,srchIndexesAllowed,srchIndexesDefault,srchJobsQuota,srchTimeWin \
| outputlookup splunk_rest_authorization_roles_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false\
| stats count

[splunk_internal_scheduler_jobs_idx_summary_tracker]
action.email.useNSSubject = 1
allow_skew = 25%
cron_schedule = 3-58/5 * * * *
dispatch.earliest_time = -10m@m
dispatch.latest_time = now
enableSched = 1
search = index=_internal sourcetype=scheduler search_group=dmc_group_search_head status=completed search_type!=datamodel_acceleration app!=splunk_archiver earliest=-10m@m latest=now \
| fields _time host savedsearch_name app user scheduled_time priority dispatch_time window_time run_time result_count search_group \
| rename host as Splunk_Instance , savedsearch_name as Savedsearch_Name , app as App , user as User , scheduled_time as Scheduled_Time , priority as Priority, dispatch_time as Dispatch_Time, window_time as Window_Time , run_time as Run_Time, result_count as Result_Count \
| eval User = lower(User) , Splunk_Instance = lower(Splunk_Instance) , User = if(User="nobody", "system", User) \
| fields - search_group \
| eval id=md5(Splunk_Instance + Savedsearch_Name) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(User) AS User \
    latest(*) AS * \
    BY id \
| search NOT \
    [ search index=`gmc_summary_index` search_name="splunk_internal_scheduler_jobs_idx_summary_tracker" earliest=-10m@m latest=now \
    | eval id=md5(Splunk_Instance + Savedsearch_Name) \
    | fields id] \
| eval search_name="splunk_internal_scheduler_jobs_idx_summary_tracker",\
   Splunk_Instance = mvjoin(mvdedup(Splunk_Instance), "|"),\
   User = mvjoin(mvdedup(User), "|")\
| table search_name Splunk_Instance Savedsearch_Name App User Scheduled_Time Dispatch_Time Priority Window_Time Run_Time Result_Count \
| collect index=`gmc_summary_index` `gmc_comment("testmode=true")` \
| stats count

[splunk_internal_web_access_idx_summary_tracker]
action.email.useNSSubject = 1
allow_skew = 25%
cron_schedule = 2-57/5 * * * *
dispatch.earliest_time = -10m@m
dispatch.latest_time = now
enableSched = 1
run_on_startup = 0
search = index=_internal sourcetype=splunk_web_access method=GET status=200 earliest=-10m@m latest=now \
    NOT view IN ("home" , "search" , "dashboard*", "alert*" , "check_alerts", "report*" , "field_extractor" , "job_manager" , "dataset*" , "pivot" , "show_source" , "charting" , "data_model*" , "flashtimeline" , "integrity_check_of_installed_files" , "licenseusage" , "live_tail" , "mod_setup" , "orphaned_scheduled_searches") \
    user!="-" \
| fields _time host search_group app view user spent \
| eval User = trim(lower(user)) , Splunk_Instance = trim(lower(host)) \
| eval id=md5(Splunk_Instance + view) \
| stats \
    values(User) AS User\
    values(Splunk_Instance) AS Splunk_Instance\
    values(app) AS App \
    values(view) AS Dashboard_Name \
    min(spent) AS min_spent\
    max(spent) AS max_spent\
    avg(spent) AS avg_spent\
    Latest(_time) As Latest_Access\
    BY id \
| search NOT \
    [ search index=`gmc_summary_index` search_name="splunk_internal_web_access_idx_summary_tracker" earliest=-10m@m latest=now \
    | eval id=md5(Splunk_Instance + Dashboard_Name) \
    | fields id] \
| eval avg_spent = round(avg_spent),\
    search_name="splunk_internal_web_access_idx_summary_tracker",\
    Splunk_Instance = mvjoin(mvdedup(Splunk_Instance), "|"),\
    User = mvjoin(mvdedup(User), "|"),\
    App = mvjoin(mvdedup(App), "|"),\
    Dashboard_Name = mvjoin(mvdedup(Dashboard_Name), "|") \
| table search_name Splunk_Instance App Dashboard_Name User Latest_Access min_spent max_spent avg_spent \
| collect index=`gmc_summary_index` `gmc_comment("testmode=true")` \
| stats count

[splunk_assets_kv_store_lookup_gen]
allow_skew = 0
cron_schedule = 0 2 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/server/info splunk_server_group="*" timeout=0 \
| rename eai:acl.* AS *, field.* AS * , splunk_server AS Splunk_Instance \
| eval Splunk_Instance=lower(Splunk_Instance) \
| `get_shcluster_info(Splunk_Instance)` \
| `get_idxcluster_label(Splunk_Instance)` \
| fields Splunk_Instance idxcluster_label shcluster_label search_group serverName host host_fqdn host_resolved server_roles mode guid version build os_name os_name_extended cpu_arch os_version os_build startup_time kvStoreStatus numberOfCores numberOfVirtualCores physicalMemoryMB rtsearch_enabled master_uri master_guid licenseState isForwarding isTrial license_labels \
| join Splunk_Instance \
    [| rest /servicesNS/-/-/admin/system-info splunk_server_group="*" timeout=0 \
    | rename "eai:acl.*" AS "*", "eai:*" AS "*" , transparent_hugepages.* AS transparent_hugepages_* , ulimits.* AS ulimits_* , splunk_server AS Splunk_Instance \
    | eval Splunk_Instance=lower(Splunk_Instance) \
    | fields - "perms.*", "can_*", id, published, removable, modifiable, updated \
    | fields Splunk_Instance transparent_hugepages_defrag transparent_hugepages_effective_state transparent_hugepages_enabled ulimits_core_file_size ulimits_cpu_time ulimits_data_file_size ulimits_data_segment_size ulimits_nice ulimits_open_files ulimits_resident_memory_size ulimits_stack_size ulimits_user_processes ulimits_virtual_address_space_size] \
| join Splunk_Instance type=left \
    [| inputlookup dmc_assets \
    | fields host peerURI \
    | rename host AS Splunk_Instance \
    | eval Splunk_Instance=lower(Splunk_Instance) \
    | stats \
        last(peerURI) AS host_ip \
        by Splunk_Instance \
    | rex field=host_ip mode=sed "s/:8089//g" \
    | fields Splunk_Instance host_ip] \
| `get_dmc_assets_info(Splunk_Instance)` \
| rex field=search_group max_match=100 "dmc_customgroup_(?<Splunk_Custom_Roles>.*?)$" \
| join Splunk_Instance type=left \
    [| rest /services/server/settings splunk_server_group=* timeout=0 \
    | fields splunk_server serverName host host_resolved SPLUNK_DB SPLUNK_HOME appServerPorts dfsDisabled dfsMasterPort enableSplunkWebSSL httpport kvStoreDisabled kvStorePort mgmtHostPort minFreeSpace sessionTimeout startwebserver trustedIP \
    | rename splunk_server AS Splunk_Instance \
    | eval Splunk_Instance=lower(Splunk_Instance) \
    | fields Splunk_Instance serverName host host_resolved SPLUNK_DB SPLUNK_HOME appServerPorts dfsDisabled dfsMasterPort enableSplunkWebSSL httpport kvStoreDisabled kvStorePort mgmtHostPort minFreeSpace sessionTimeout startwebserver trustedIP \
    | stats \
        last(*) as * \
        by Splunk_Instance \
    | fields Splunk_Instance serverName host host_resolved SPLUNK_DB SPLUNK_HOME appServerPorts dfsDisabled dfsMasterPort enableSplunkWebSSL httpport kvStoreDisabled kvStorePort mgmtHostPort minFreeSpace sessionTimeout startwebserver trustedIP ] \
| stats \
    values(server_roles) AS Splunk_Roles \
    values(Splunk_Custom_Roles) AS Splunk_Custom_Roles \
    last(*) AS *\
    BY Splunk_Instance \
| eval Splunk_Roles=mvappend(Splunk_Roles, Splunk_Custom_Roles) , Splunk_Roles=mvdedup(mvsort(Splunk_Roles)) \
| eval host_short_tmp = mvindex ( split(host_fqdn, "."), 0 ) , host_short = if ( len (host_short_tmp) > 3, host_short_tmp, null()) \
| table Splunk_Instance Splunk_Roles serverName host host_short host_fqdn host_resolved host_ip idxcluster_label shcluster_label mode guid version build os_name os_name_extended cpu_arch os_version os_build startup_time kvStoreStatus numberOfCores numberOfVirtualCores physicalMemoryMB rtsearch_enabled master_uri master_guid licenseState isForwarding isTrial license_labels transparent_hugepages_defrag transparent_hugepages_effective_state transparent_hugepages_enabled ulimits_core_file_size ulimits_cpu_time ulimits_data_file_size ulimits_data_segment_size ulimits_nice ulimits_open_files ulimits_resident_memory_size ulimits_stack_size ulimits_user_processes ulimits_virtual_address_space_size SPLUNK_DB SPLUNK_HOME appServerPorts dfsDisabled dfsMasterPort enableSplunkWebSSL httpport kvStoreDisabled kvStorePort mgmtHostPort minFreeSpace sessionTimeout startwebserver trustedIP \
| outputlookup splunk_assets_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_identities_kv_store_lookup_gen]
allow_skew = 25%
cron_schedule = 10 2 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_priority = higher
schedule_window = 0
search = | rest /servicesNS/-/-/authentication/users splunk_server_group="dmc_group_search_head" timeout=0 \
| fields splunk_server title email realname defaultAppSourceRole last_successful_login locked-out roles type tz \
| rename title AS identity , realname AS emp_name splunk_server AS Splunk_Instance roles As splunk_role_map \
| join splunk_role_map type=left \
    [| rest /servicesNS/-/-/admin/LDAP-groups splunk_server_group="dmc_group_search_head" timeout=0 \
    | rename "eai:acl.*" As "*", "eai:*" As "*" \
    | fields title roles type \
    | rename title As ldap_group_name, type As ldap_group_type, roles As splunk_role_map] \
| join identity type=left \
    [| rest /servicesNS/-/-/search/jobs/export splunk_server_group=`es_search_head` timeout=0 search="|from lookup:identity_lookup_expanded|search NOT identity=\"\"|search NOT [| inputlookup administrative_identity_lookup|fields identity]|table identity,prefix,nick,first,last,suffix,email,phone,managedBy,priority,bunit,category,watchl`ist,startDate,endDate,work_city,work_country,work_lat,work_long | eval category=mvfilter(!match(category,\"default|privileged|gen:|computer|nha|pci|pip|sox|cardholder\")), identity=mvfilter(!match(identity,\"cn=|ou=|\@|\s|\\\\\\\\\") AND len(identity) < 40), identity=mvjoin(mvdedup(mvsort(identity)), \"|\"),email=mvjoin(email,\"|\"),phone=mvjoin(phone, \"|\"),category=mvjoin(category, \"|\") | stats last(*) as * by identity| table identity,prefix,nick,first,last,suffix,email,phone,managedBy,priority,bunit,category,watchlist,startDate,endDate,work_city,work_country,work_lat,work_long" output_mode=csv \
    | rex mode=sed field=value "s/\"//g" \
    | fields value \
    | rex max_match=100 field=value "(?P<value>^.+)\s" \
    | stats count BY value \
    | fields - count \
    | eval temp=split(value,",") \
    | eval identity=mvindex(temp,0), prefix=mvindex(temp,1), nick=mvindex(temp,2), first=mvindex(temp,3), last=mvindex(temp,4), suffix=mvindex(temp,5), email=mvindex(temp,6), phone=mvindex(temp,7), managedBy=mvindex(temp,8), priority=mvindex(temp,9), bunit=mvindex(temp,10), category=mvindex(temp,11), watchlist=mvindex(temp,12), startDate=mvindex(temp,13), endDate=mvindex(temp,14), work_city=mvindex(temp,15), work_country=mvindex(temp,16), work_lat=mvindex(temp,17), work_long=mvindex(temp,18) \
    | table identity,prefix,nick,first,last,suffix,email,phone,managedBy,priority,bunit,category,watchlist,startDate,endDate,work_city,work_country,work_lat,work_long \
    | where identity!="identity" AND identity!="true" AND identity!="false" \
    | makemv delim="," identity \
    | makemv delim="," email \
    | makemv delim="," phone \
    | makemv delim="," category] \
| eval emp_name=if(emp_name="" OR isnull(emp_name), null(), emp_name) \
| `get_identity_custom_info(identity)` \
| `fix_identities_info` \
| `set_geo_defaults` \
| eval \
    identity=lower(trim(identity)),\
    email = lower(email), last_successful_login=if(last_successful_login=0,null(),last_successful_login) \
| `get_shcluster_label(Splunk_Instance)` \
| stats \
    values(emp_name) AS emp_name values(prefix) AS prefix values(nick) AS nick values(first) AS first values(last) AS last values(suffix) AS suffix\
    values(email) AS email\
    values(phone) AS phone values(phone2) AS phone2\
    values(managedBy) AS managedBy\
    values(priority) AS priority values(bunit) AS bunit values(category) AS category values(watchlist) AS watchlist\
    values(startDate) AS startDate values(endDate) AS endDate\
    values(work_city) AS work_city values(work_region) AS work_region values(work_country) AS work_country values(work_lat) AS work_lat values(work_long) AS work_long \
    values(emp_floor) AS emp_floor values(emp_loc) AS emp_loc\
    values(emp_cc) AS emp_cc values(emp_dep) AS emp_dep values(emp_lob) AS emp_lob\
    values(emp_type) AS emp_type values(emp_status) AS emp_status\
    values(emp_ttl) AS emp_ttl\
    values(emp_tz) AS emp_tz\
    values(splunk_role_map) AS splunk_role_map\
    values(ldap_group_name) As ldap_group_name\
    values(ldap_group_type) As ldap_group_type\
    values(last_successful_login) AS last_successful_login\
    values(Splunk_Instance) AS Splunk_Instance\
    BY shcluster_label identity \
| foreach * \
    [ eval <<FIELD>>=mvdedup('<<FIELD>>')] \
| table shcluster_label,identity,Splunk_Instance,prefix,nick,first,last,suffix,email,phone,phone2,managedBy,priority,bunit,category,watchlist,startDate,endDate,work_city,work_country,work_lat,work_long,work_region,emp_cc,emp_dep,emp_floor,emp_lob,emp_loc,emp_name,emp_type,emp_status,emp_ttl,emp_tz,splunk_role_map,ldap_group_name,ldap_group_type,last_successful_login \
| outputlookup splunk_identities_kv_store_lookup CreateInApp=True Create_Empty=True Override_If_Empty=False \
| stats count

[splunk_audit_user_login_idx_summary_tracker]
action.email.useNSSubject = 1
allow_skew = 25%
cron_schedule = 1-56/5 * * * *
dispatch.earliest_time = -10m@m
dispatch.latest_time = now
enableSched = 1
search = ((index=_audit sourcetype=audittrail) AND (user=* "action=login attempt" info=succeeded)) OR (index=_internal sourcetype=splunkd_ui_access useragent=* status=200 user!="-") earliest=-10m@m latest=now \
| eval search_type = if(match(search_id, "\d{10}\.\d+(_[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12})?$"), "adhoc", "other") \
| search info="succeeded" OR search_type="adhoc" OR (index=_internal sourcetype=splunkd_ui_access useragent=* status=200 user!="-") \
| rex field=useragent "(?<Browser_and_Version>(MSIE|Trident|(?!Gecko.+)Firefox|(?!AppleWebKit.+Chrome.+)Safari(?!.+Edge)|(?!AppleWebKit.+)Chrome(?!.+Edge)|(?!AppleWebKit.+Chrome.+Safari.+)Edge|AppleWebKit(?!.+Chrome|.+Safari)|Gecko(?!.+Firefox))(?: |\/)([\d\.apre]+)|Splunk.*?\s)" \
| rex field=useragent "(Version/|iPhone\sOS\s)(?<Safari_Version>.*?)\s" \
| rex field=Browser_and_Version "(?<Browser_Name>.*?)/" \
| rex field=Browser_and_Version "/(?<Browser_Version>.*?)$" \
| rex field=useragent "(?<Architecture>(Win64|x86_64))" \
| rex field=useragent "(?<OS_Name>(Linux|Macintosh|Windows\s*\w+|iPhone|iPad))" \
| rex field=useragent "(Linux\s|Macintosh;\s|i\w+;\s|Windows\sNT\s)(?<OS_Version>.*?)[;)]" \
| eval \
    Browser_Version = if(isnotnull(Safari_Version), Safari_Version, Browser_Version), \
    Browser_Name=if(Browser_Name="Trident", "Internet Explorer", Browser_Name), \
    OS_Name = case ( \
    match(useragent,"Windows NT 6.1"), "Windows 7", \
    match(useragent,"Windows NT 6.2"), "Windows 8", \
    match(useragent,"Windows NT 6.3"), "Windows 8.1", \
    match(useragent,"Windows NT 10.0"), "Windows 10", \
    match(useragent,"Pixel"), "Google Pixel",\
    match(useragent,"Android"), "Android", \
    true(), OS_Name ) , \
    Splunk_Instance = trim(lower(host)) ,\
    Login_Source = lower(src) , \
    Login_Source=mvsort(mvdedup((mvappend(Login_Source, clientip)))),\
    id=md5(lower(user)) \
| fields _time id user Login_Source Splunk_Instance OS_Name OS_Version Browser_Name Browser_Version \
| stats \
    values(Splunk_Instance) as Splunk_Instance \
    values(Login_Source) as Login_Source \
    values(OS_Name) as OS_Name\
    values(OS_Version) as OS_Version\
    values(Browser_Name) as Browser_Name\
    values(Browser_Version) as Browser_Version\
    latest(user) as User \
    Latest(_time) As Latest_Access\
    BY id \
| search NOT \
    [ search index=`gmc_summary_index` search_name="splunk_audit_user_login_idx_summary_tracker" earliest=-10m@m latest=now \
    | eval id=md5(lower(User)) \
    | fields id] \
| eval \
    Login_Source = mvfilter ( ! match (Login_Source,"127.0.0.1|\*") ),\
    OS_Name = mvfilter ( ! match (OS_Name,"\*") ),\
    OS_Version = mvfilter ( ! match (OS_Version,"\*") ),\
    Browser_Name = mvfilter ( ! match (Browser_Name,"\*") ),\
    Browser_Version = mvfilter ( ! match (Browser_Version,"\*") ), \
    Splunk_Instance = mvjoin(mvdedup(Splunk_Instance), "|"),\
    Login_Source = mvjoin(mvdedup(Login_Source), "|"),\
    OS_Name = mvjoin(mvdedup(OS_Name), "|"),\
    OS_Version = mvjoin(mvdedup(OS_Version), "|"),\
    Browser_Name = mvjoin(mvdedup(Browser_Name), "|"),\
    Browser_Version = mvjoin(mvdedup(Browser_Version), "|") \
| foreach Login_Source Splunk_Instance OS_Name OS_Version Browser_Name Browser_Version \
    [ eval <<FIELD>>=mvsort(mvdedup('<<FIELD>>'))] \
| eval search_name="splunk_audit_user_login_idx_summary_tracker" \
| table search_name Splunk_Instance User Login_Source Latest_Access OS_Name OS_Version Browser_Name Browser_Version \
| collect index=`gmc_summary_index` `gmc_comment("testmode=true")` \
| stats count

[splunk_index_internal_web_access_tracker_sh_kv_store_lookup_tracker]
allow_skew = 25%
cron_schedule = 2-57/5 * * * *
dispatch.earliest_time = -10m@m
dispatch.latest_time = -5m@m
enableSched = 1
schedule_priority = highest
search = index=_internal sourcetype=splunk_web_access method=GET status=200 user!="-" \
    `gmc_comment("  NOT view IN ("home" , "search" , "dashboard*", "alert*" , "check_alerts", "report*" , "field_extractor" , "job_manager" , "dataset*" , "pivot" , "show_source" , "charting" , "data_model*" , "flashtimeline" , "integrity_check_of_installed_files" , "licenseusage" , "live_tail" , "mod_setup" , "orphaned_scheduled_searches") ")` \
| fields _time host search_group app view user spent \
| eval User = trim(lower(user)) , Splunk_Instance = trim(lower(host)) \
| `get_instance_roles(Splunk_Instance)` \
| `get_shcluster_label(Splunk_Instance)` \
| eval locator=md5(Splunk_Instance + view) \
| stats \
    earliest(_time) AS Earliest_Access\
    latest(_time) AS Latest_Access\
    values(User) AS User\
    values(Splunk_Instance) AS Splunk_Instance\
    values(shcluster_label) AS shcluster_label \
    values(app) AS App \
    values(view) AS Dashboard_Name \
    min(spent) AS min_spent\
    max(spent) AS max_spent\
    avg(spent) AS avg_spent\
    BY locator \
| eval avg_spent = round(avg_spent) \
| table locator shcluster_label Splunk_Instance App Dashboard_Name User Earliest_Access Latest_Access min_spent max_spent avg_spent \
| outputlookup splunk_index_internal_web_access_tracker_sh_kv_store_lookup key_field=locator createinapp=true \
| stats count

[Generate_Random_Daily_License_Usage_Data_for_ML_Forecasting]
cron_schedule = 0 6 * * 1
dispatch.earliest_time = -5m
dispatch.latest_time = now
search = | gentimes start=1/1/2020 end=04/02/2020 increment=1d \
| fields starthuman endhuman \
| eval _time=strptime(starthuman,"%a %B %d %H:%M:%S.%N %Y") \
| eval low = 1073741824 , high = 2147483648 , idxcluster_label="org_idx_cluster1", Lic_Stack_Size=53687091200 \
| eval Lic_Pool=mvappend("IDX1_Pool","IDX2_Pool","IDX3_Pool") \
| eval License_Usage = round(((random() % high)/(high)) * (high - low) + low) \
| stats \
    sum(License_Usage) AS License_Usage \
    latest(Lic_Stack_Size) AS Lic_Stack_Size\
    BY _time idxcluster_label Lic_Pool \
| eval search_name="splunk_internal_license_rollover_summary_idx_summary_tracker" , type="RolloverSummary" \
| table _time search_name idxcluster_label Lic_Pool type Lic_Stack_Size License_Usage \
| collect index=`gmc_summary_index` testmode=true

[splunk_saved_searches_drift_alert]
description = Monitor for changes made to any or specific (configurable) Saved Searches changes in the environment and send an automated Alert via GMC.
dispatch.earliest_time = -1h
dispatch.latest_time = now
quantity = 0
relation = greater than
search = index=_internal sourcetype=splunkd_ui_access method=POST uri="*/saved/searches*" NOT file IN (acl, dispatch, searches) \
| fields - useragent \
| fields _time clientip file host status user user uri \
| rex field=uri "\N+servicesNS/[^/]+/(?<app>[^/]+)/[^/]+/[^/]+/(?<savedsearch_name>\N+)$" \
| rex field=savedsearch_name mode=sed "s/%20/ /g" \
| search savedsearch_name IN ("*") `gmc_comment("Add any specific Reports/Alerts you like to monitor for or leave to monitor for all changes")` \
| `get_shcluster_label(host)` \
| `get_saved_searches_info(shcluster_label,app,savedsearch_name)` \
| fields _time shcluster_label clientip file host app status user uri savedsearch_search cron_schedule is_scheduled schedule_priority schedule_window action_email_to allow_skew auto_summarize realtime_schedule savedsearch_type savedsearch_name dispatch_earliest_time dispatch_latest_time action_email updated \
| rename \
    disabled AS old_disabled\
    updated as old_updated\
    cron_schedule as old_cron_schedule \
    is_scheduled as old_is_scheduled \
    dispatch_earliest_time as old_dispatch_earliest_time\
    dispatch_latest_time as old_dispatch_latest_time \
    action_email as old_action_email \
    action_email_to as old_action_email_to\
    schedule_priority as old_schedule_priority \
    schedule_window as old_schedule_window\
    action_email_to as old_action_email_to\
    allow_skew as old_allow_skew\
    auto_summarize as old_auto_summarize\
    realtime_schedule as old_realtime_schedule \
    savedsearch_search as old_savedsearch_search \
    savedsearch_type as old_savedsearch_type \
| fields shcluster_label app savedsearch_name old_* _time clientip file host status user uri \
| join shcluster_label app savedsearch_name \
    [| rest /servicesNS/-/-/saved/searches splunk_server_group=dmc_group_search_head timeout=0 \
    | eval savedsearch_type=if((NOT 'action'=="*" AND NOT alert.track=="*" AND NOT alert_condition=="*" AND 'alert_type'=="always"),"report","alert") \
    | rename eai:acl.app AS app, splunk_server AS Splunk_Instance, title AS savedsearch_name, alert.severity AS alert_severity, alert.track AS alert_track, dispatch.earliest_time AS dispatch_earliest_time, dispatch.latest_time AS dispatch_latest_time , eai:acl.sharing as sharing , eai:acl.removable as removable action.email.to AS action_email_to \
    | rename action.email AS action_email action.logevent AS action_logevent action.logevent.param.event AS action_logevent_param_event action.lookup AS action_lookup action.lookup.append AS action_lookup_append action.lookup.filename AS action_lookup_filename action.output_message AS action_output_message action.output_message.param.msgid AS action_output_message_param_msgid action.output_message.param.name AS action_output_message_param_name action.populate_lookup AS action_populate_lookup action.script AS action_script action.script.filename AS action_script_filename action.summary_index AS action_summary_index auto_summarize.cron_schedule AS auto_summarize_cron_schedule auto_summarize.max_concurrent AS auto_summarize_max_concurrent dispatch.ttl AS dispatch_ttl auto_summarize.dispatch.earliest_time AS auto_summarize_dispatch_earliest_time auto_summarize.dispatch.latest_time AS auto_summarize_dispatch_latest_time action.correlationsearch.enabled AS action_correlationsearch_enabled action.correlationsearch.label AS action_correlationsearch_label action.correlationsearch.related_searches AS action_correlationsearch_related_searches \
    | `strptime_format(updated)` \
    | `get_shcluster_label(Splunk_Instance)` \
    | fields shcluster_label app savedsearch_name updated disabled is_scheduled cron_schedule auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority schedule_window allow_skew realtime_schedule action_email_to search action_email savedsearch_type \
    | stats \
        last(*) AS * \
        BY shcluster_label app savedsearch_name \
    | rename \
        cron_schedule as new_cron_schedule \
        is_scheduled as new_is_scheduled\
        dispatch_earliest_time as new_dispatch_earliest_time \
        dispatch_latest_time as new_dispatch_latest_time \
        action_email as new_action_email \
        action_email_to as new_action_email_to\
        schedule_priority as new_schedule_priority\
        schedule_window as new_schedule_window \
        allow_skew as new_allow_skew\
        auto_summarize as new_auto_summarize \
        realtime_schedule as new_realtime_schedule \
        search as new_savedsearch_search\
        savedsearch_type as new_savedsearch_type \
        updated AS new_updated\
        disabled as new_disabled \
    | fields shcluster_label app savedsearch_name new_*] \
| stats values(*) as * latest(_time) as _time by shcluster_label app savedsearch_name user \
| convert ctime(*_updated) \
| table _time user clientip status host shcluster_label app savedsearch_name \
    old_savedsearch_type new_savedsearch_type\
    old_updated new_updated\
    old_disabled new_disabled\
    old_cron_schedule new_cron_schedule\
    old_is_scheduled new_is_scheduled \
    old_dispatch_earliest_time new_dispatch_earliest_time\
    old_dispatch_latest_time new_dispatch_latest_time\
    old_action_email new_action_email\
    old_action_email_to new_action_email_to\
    old_action_email_to new_action_email_to\
    old_schedule_priority new_schedule_priority\
    old_schedule_window new_schedule_window\
    old_allow_skew new_allow_skew\
    old_auto_summarize new_auto_summarize\
    old_realtime_schedule new_realtime_schedule\
    old_savedsearch_search new_savedsearch_search

[splunk_rest_saved_searches_sh_monitoring_kv_store_lookup_gen]
allow_skew = 0
dispatch.earliest_time = -1s
dispatch.latest_time = now
schedule_window = 0
search = | rest /servicesNS/-/-/saved/searches splunk_server_group=dmc_group_search_head timeout=0 earliest_time=-1d@d latest_time=-0d@d \
| eval savedsearch_type=if((NOT 'action'=="*" AND NOT alert.track=="*" AND NOT alert_condition=="*" AND 'alert_type'=="always"),"report","alert") \
| rename eai:acl.app AS app, splunk_server AS Splunk_Instance, title AS savedsearch_name, alert.severity AS alert_severity, alert.track AS alert_track, dispatch.earliest_time AS dispatch_earliest_time, dispatch.latest_time AS dispatch_latest_time , eai:acl.sharing as sharing , eai:acl.removable as removable action.email.to AS action_email_to \
| rename action.email AS action_email action.logevent AS action_logevent action.logevent.param.event AS action_logevent_param_event action.lookup AS action_lookup action.lookup.append AS action_lookup_append action.lookup.filename AS action_lookup_filename action.output_message AS action_output_message action.output_message.param.msgid AS action_output_message_param_msgid action.output_message.param.name AS action_output_message_param_name action.populate_lookup AS action_populate_lookup action.script AS action_script action.script.filename AS action_script_filename action.summary_index AS action_summary_index action.summary_index._name AS action_summary_index_name auto_summarize.cron_schedule AS auto_summarize_cron_schedule auto_summarize.max_concurrent AS auto_summarize_max_concurrent dispatch.ttl AS dispatch_ttl auto_summarize.dispatch.earliest_time AS auto_summarize_dispatch_earliest_time auto_summarize.dispatch.latest_time AS auto_summarize_dispatch_latest_time action.correlationsearch.enabled AS action_correlationsearch_enabled action.correlationsearch.label AS action_correlationsearch_label action.correlationsearch.related_searches AS action_correlationsearch_related_searches \
| `strptime_format(updated)` \
| `get_shcluster_label(Splunk_Instance)` \
| eval author = if(author="nobody", "system", author) ,\
    next_scheduled_time=strptime(next_scheduled_time,"%Y-%m-%d %H:%M:%S %Z") \
| fields shcluster_label Splunk_Instance app savedsearch_name description savedsearch_type sharing author updated disabled is_visible is_scheduled cron_schedule scheduled_times next_scheduled_time auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule alert_severity alert_track alert_type removable run_n_times run_on_startup action_email_to search action_email action_logevent action_logevent_param_event action_lookup action_lookup_append action_lookup_filename action_output_message action_output_message_param_msgid action_output_message_param_name action_populate_lookup action_script action_script_filename action_summary_index action_summary_index_name auto_summarize_cron_schedule auto_summarize_dispatch_earliest_time auto_summarize_dispatch_latest_time auto_summarize_max_concurrent dispatch_ttl action_correlationsearch_enabled action_correlationsearch_label action_correlationsearch_related_searches \
| makemv delim="," action_correlationsearch_related_searches \
| rex field=action_correlationsearch_related_searches mode=sed "s/\[\"|\"\]|\[|\]|\"//g" \
| rex field=search "\|\s*collect\s+index=(?<action_summary_index_name>.*?)\s" \
| eval \
    action_correlationsearch_related_searches = mvdedup(mvsort(trim(action_correlationsearch_related_searches))),\
    action_summary_index = if(match(search, "\|\s*collect\s+"), 1, action_summary_index),\
    action_summary_index_name = trim(action_summary_index_name) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(scheduled_times) as scheduled_times\
    values(action_correlationsearch_related_searches) AS action_correlationsearch_related_searches\
    last(*) AS * \
    BY shcluster_label app savedsearch_name \
| eval scheduled_times = mvindex(scheduled_times, 0, 4) \
| table shcluster_label Splunk_Instance app savedsearch_name description savedsearch_type sharing author updated disabled is_visible is_scheduled cron_schedule scheduled_times next_scheduled_time auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule alert_severity alert_track alert_type removable run_n_times run_on_startup action_email_to search action_email action_logevent action_logevent_param_event action_lookup action_lookup_append action_lookup_filename action_output_message action_output_message_param_msgid action_output_message_param_name action_populate_lookup action_script action_script_filename action_summary_index action_summary_index_name auto_summarize_cron_schedule auto_summarize_dispatch_earliest_time auto_summarize_dispatch_latest_time auto_summarize_max_concurrent dispatch_ttl action_correlationsearch_enabled action_correlationsearch_label action_correlationsearch_related_searches \
| outputlookup splunk_rest_saved_searches_sh_monitoring_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_index_internal_web_access_tracker_sh_kv_store_lookup_backup_gen]
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | inputlookup splunk_index_internal_web_access_tracker_sh_kv_store_lookup \
| fields shcluster_label Splunk_Instance App Dashboard_Name User Earliest_Access Latest_Access min_spent max_spent avg_spent \
| eval shcluster_label=mvjoin(shcluster_label,","), \
    Splunk_Instance=mvjoin(Splunk_Instance,","), \
    App=mvjoin(App,","), \
    User=mvjoin(User,","),\
    User=mvjoin(Dashboard_Name,",") \
| eval locator=md5(Splunk_Instance + Dashboard_Name) \
| stats \
    last(Earliest_Access) AS Earliest_Access\
    last(Latest_Access) AS Latest_Access\
    values(User) AS User\
    values(Splunk_Instance) AS Splunk_Instance\
    values(shcluster_label) AS shcluster_label \
    values(App) AS App \
    values(Dashboard_Name) AS Dashboard_Name \
    last(min_spent) AS min_spent\
    last(max_spent) AS max_spent\
    last(avg_spent) AS avg_spent\
    BY locator \
| eval User=mvjoin(mvdedup(User), ",") \
| table locator shcluster_label Splunk_Instance App Dashboard_Name User Earliest_Access Latest_Access min_spent max_spent avg_spent \
| `gmc_comment("| outputlookup splunk_index_internal_web_access_tracker_sh_kv_store_lookup_backup.csv")`

[splunk_rest_cluster_config_idx_kv_store_lookup_gen]
allow_skew = 0
cron_schedule = 10 3 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_priority = higher
schedule_window = 0
search = | rest /services/cluster/config splunk_server_group=dmc_group_indexer timeout=0 \
| where forwarderdata_rcv_port!="?" \
| rename splunk_server AS Splunk_Instance cluster_label AS idxcluster_label \
    `gmc_comment("splunk_server cluster_label guid master_uri mode access_logging_for_heartbeats allowed_hbmiss_count cxn_timeout decommission_node_force_timeout decommission_search_jobs_wait_secs disabled forwarderdata_rcv_port forwarderdata_use_ssl frozen_notifications_per_batch heartbeat_period heartbeat_timeout manual_detention max_auto_service_interval max_fixup_time_ms max_peer_build_load max_peer_rep_load max_peer_sum_rep_load max_peers_to_download_bundle max_primary_backups_per_service notify_scan_min_period notify_scan_period percent_peers_to_restart ping_flag quiet_period rcv_timeout register_forwarder_address register_replication_address register_search_address remote_storage_upload_timeout rep_cxn_timeout rep_max_rcv_timeout rep_max_send_timeout rep_rcv_timeout rep_send_timeout replication_factor replication_port replication_use_ssl report_remote_storage_bucket_upload_to_targets reporting_delay_period restart_timeout search_factor search_files_retry_timeout send_timeout service_interval site warm_bucket_replication_pre_upload")` \
| fields Splunk_Instance master_uri idxcluster_label forwarderdata_rcv_port guid \
| rex field=master_uri "https://(?<idxcluster_label_tmp>.*?):8089" \
| eval idxcluster_label = if (isnull(idxcluster_label) OR idxcluster_label="" OR len(idxcluster_label)=36, idxcluster_label_tmp, idxcluster_label) \
| eval idxcluster_label = if (isnull(idxcluster_label) OR idxcluster_label="", Splunk_Instance, idxcluster_label) \
| fields - idxcluster_label_tmp \
| stats \
    values(*) as * \
    by Splunk_Instance master_uri \
| eval Splunk_Instance = lower(Splunk_Instance) \
| table Splunk_Instance master_uri idxcluster_label forwarderdata_rcv_port guid \
| outputlookup splunk_rest_cluster_config_idx_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_saved_searches_sh_drift_monitoring]
action.email.useNSSubject = 1
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | inputlookup splunk_rest_saved_searches_sh_monitoring_kv_store_lookup \
| table shcluster_label app savedsearch_name disabled is_scheduled cron_schedule auto_summarize dispatch_earliest_time dispatch_latest_time schedule_priority max_concurrent schedule_window allow_skew realtime_schedule \
| rename disabled As disabled_old is_scheduled As is_scheduled_old cron_schedule As cron_schedule_old auto_summarize As auto_summarize_old dispatch_earliest_time As dispatch_earliest_time_old dispatch_latest_time As dispatch_latest_time_old schedule_priority As schedule_priority_old max_concurrent As max_concurrent_old schedule_window As schedule_window_old allow_skew As allow_skew_old realtime_schedule As realtime_schedule_old \
| lookup splunk_rest_saved_searches_sh_kv_store_lookup shcluster_label app savedsearch_name OUTPUT is_scheduled As is_scheduled_new disabled AS disabled_new cron_schedule As cron_schedule_new auto_summarize As auto_summarize_new dispatch_earliest_time As dispatch_earliest_time_new dispatch_latest_time As dispatch_latest_time_new schedule_priority As schedule_priority_new max_concurrent As max_concurrent_new schedule_window As schedule_window_new allow_skew As allow_skew_new realtime_schedule As realtime_schedule_new \
| where is_scheduled_old!=is_scheduled_new OR disabled_old!=disabled_new OR cron_schedule_old!=cron_schedule_new OR auto_summarize_old!=auto_summarize_new OR dispatch_earliest_time_old!=dispatch_earliest_time_new OR dispatch_latest_time_old!=dispatch_latest_time_new OR schedule_priority_old!=schedule_priority_new OR max_concurrent_old!=max_concurrent_new OR schedule_window_old!=schedule_window_new OR allow_skew_old!=allow_skew_new OR realtime_schedule_old!=realtime_schedule_new \
| join savedsearch_name \
    [ search index=_internal sourcetype=splunkd_ui_access method=POST uri="*/saved/searches*" NOT file IN (acl, dispatch, searches) earliest=-24h@h latest=now \
    | fields _time clientip file host status user user uri \
    | rex field=uri "\N+servicesNS/[^/]+/(?<app>[^/]+)/[^/]+/[^/]+/(?<savedsearch_name>\N+)$" \
    | rex field=savedsearch_name mode=sed "s/%20/ /g" \
    | fields savedsearch_name user ] \
| table shcluster_label app savedsearch_name user is_scheduled_old is_scheduled_new disabled_old disabled_new cron_schedule_old cron_schedule_new auto_summarize_old auto_summarize_new dispatch_earliest_time_old dispatch_earliest_time_new dispatch_latest_time_old dispatch_latest_time_new schedule_priority_old schedule_priority_new max_concurrent_old max_concurrent_new schedule_window_old schedule_window_new allow_skew_old allow_skew_new realtime_schedule_old realtime_schedule_new

[splunk_rest_data_inputs_http_sh_kv_store_lookup_gen]
disabled = 0
enableSched = 1
cron_schedule = 40 12 * * *
schedule_window = 0
schedule_priority = default
allow_skew = 0
run_on_startup = 0
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | rest splunk_server_group=* /servicesNS/-/-/data/inputs/http timeout=0 \
| rename "eai:acl.*" as "*", "eai:*" as "*" , splunk_server AS Splunk_Instance \
| eval token_name=substr('title', 8) \
| `get_shcluster_label(Splunk_Instance)` \
| `get_idxcluster_label(Splunk_Instance)` \
| fields shcluster_label idxcluster_label Splunk_Instance app title token_name token disabled index indexes source sourcetype useACK \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(idxcluster_label) AS idxcluster_label \
    last(*) as * \
    by shcluster_label app title \
| eval tags = mvjoin(tags, ",") \
| table shcluster_label idxcluster_label Splunk_Instance app title token_name token disabled index indexes source sourcetype useACK\
| outputlookup splunk_rest_data_inputs_http_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_itoa_interface_service_sh_kv_store_lookup_gen]
disabled = 0
enableSched = 1
cron_schedule = 10 12 * * *
schedule_window = 0
schedule_priority = default
allow_skew = 0
run_on_startup = 0
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | rest /servicesNS/nobody/SA-ITOA/itoa_interface/service fields="_key,title,kpis._key,kpis.title,kpis.type,kpis.search_type,kpis.base_search_id,kpis.base_search_metric,kpis.alert_period,kpis.urgency,kpis.search,kpis.search_entities,kpis.search_aggregate,kpis.search_alert,kpis.backfill_enabled,kpis.backfill_earliest_time,kpis.adaptive_thresholds_is_enabled,kpis.anomaly_detection_is_enabled,kpis.entity_statop,kpis.aggregate_statop,kpis.threshold_field,kpis.entity_id_fields,kpis.search_alert_earliest" report_as=text splunk_server_group="dmc_group_search_head" timeout=0 \
| eval value=spath(value,"{}") \
| mvexpand value \
| eval service_id=spath(value,"_key"), service_title=spath(value,"title"), value=spath(value,"kpis{}") \
| mvexpand value \
| foreach _key search_type base_search_id base_search_metric alert_period title type urgency search search_entities search_aggregate search_alert backfill_enabled backfill_earliest_time adaptive_thresholds_is_enabled anomaly_detection_is_enabled entity_statop aggregate_statop threshold_field entity_id_fields search_alert_earliest \
    [ eval <<FIELD>>=spath(value,"<<FIELD>>") ] \
| rename _key as kpi_id title as kpi_title splunk_server As Splunk_Instance \
| search kpi_title!=ServiceHealthScore \
| fields Splunk_Instance service_id service_title kpi_id kpi_title base_search_id type search_type threshold_field entity_id_fields entity_statop aggregate_statop alert_period urgency backfill_enabled backfill_earliest_time adaptive_thresholds_is_enabled anomaly_detection_is_enabled search_alert_earliest \
| `get_shcluster_label(Splunk_Instance)` \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    last(*) as * \
    BY shcluster_label service_id kpi_id \
| table shcluster_label Splunk_Instance service_id service_title kpi_id kpi_title base_search_id type search_type threshold_field entity_id_fields entity_statop aggregate_statop alert_period urgency backfill_enabled backfill_earliest_time adaptive_thresholds_is_enabled anomaly_detection_is_enabled search_alert_earliest \
| outputlookup splunk_rest_itoa_interface_service_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_index_itsi_summary_sh_kv_store_lookup_gen]
disabled = 0
enableSched = 1
cron_schedule = 20 12 * * *
schedule_window = 0
schedule_priority = default
allow_skew = 0
run_on_startup = 0
dispatch.earliest_time = -60m@m
dispatch.latest_time = now
search = index=itsi_summary search_name=* NOT search_name IN ("Indicator-Disabled_kpis- ITSI search", "service_health_monitor") \
| fields host search_name serviceid kpiid \
| `get_shcluster_label(host)` \
| stats \
    count\
    By shcluster_label search_name serviceid kpiid \
| table shcluster_label search_name serviceid kpiid \
| outputlookup splunk_index_itsi_summary_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_itoa_interface_kpi_base_search_sh_kv_store_lookup_gen]
disabled = 0
enableSched = 1
cron_schedule = 30 12 * * *
schedule_window = 0
schedule_priority = default
allow_skew = 0
run_on_startup = 0
dispatch.earliest_time = -1s
dispatch.latest_time = now
search = | rest servicesNS/nobody/SA-ITOA/itoa_interface/kpi_base_search fields="_key,title,base_search" report_as=text splunk_server_group="dmc_group_search_head" timeout=0 \
| eval value=spath(value,"{}") \
| mvexpand value \
| rename splunk_server As Splunk_Instance \
| foreach _key title base_search \
    [ eval <<FIELD>>=spath(value,"<<FIELD>>") ] \
| rename _key as key \
| fields Splunk_Instance title key base_search \
| `get_shcluster_label(Splunk_Instance)` \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    last(*) as * \
    BY shcluster_label title \
| table shcluster_label Splunk_Instance title key base_search \
| outputlookup splunk_rest_itoa_interface_kpi_base_search_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_apps_local_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 0 3 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/apps/local splunk_server_group="*" timeout=0 \
| rename eai:acl.* as * , splunk_server AS Splunk_Instance , perms.read As acl_perms_read , perms.write As acl_perms_write \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| fields shcluster_label Splunk_Instance title label core author version build check_for_updates visible sharing disabled configured show_in_nav state_change_requires_restart description details updated acl_perms_read acl_perms_write \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(acl_perms_read) AS acl_perms_read \
    values(acl_perms_write) AS acl_perms_write \
    last(*) as * \
    by shcluster_label title \
| table shcluster_label Splunk_Instance title label core author version build check_for_updates visible sharing disabled configured show_in_nav state_change_requires_restart description details updated acl_perms_read acl_perms_write \
| outputlookup splunk_rest_apps_local_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_data_ui_views_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 10 5 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/data/ui/views splunk_server_group=dmc_group_search_head timeout=0 search="isDashboard=1" search="isVisible=1" search="disabled=0" \
    `gmc_comment("search="eai:acl.app!=system" ")`\
    `gmc_comment("| search NOT title IN ("about", "home" , "search" , "dashboard*", "alert*" , "check_alerts", "report*" , "field_extractor" , "job_manager" , "dataset*" , "pivot" , "show_source" , "charting" , "data_model*" , "flashtimeline" , "integrity_check_of_installed_files" , "licenseusage" , "live_tail" , "mod_setup" , "orphaned_scheduled_searches", "setup", "sample_*") ")` \
| rename eai:* AS * , acl.* AS * , splunk_server AS Splunk_Instance , perms.read As acl_perms_read perms.write As acl_perms_write \
| fields Splunk_Instance app sharing title label description type author updated data id acl_perms_read acl_perms_write \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| rex field=id mode=sed "s/^https:\/\/127.0.0.1:8089\/servicesNS\///g" \
| rex field=id mode=sed "s/^nobody/apps/g" \
| rex field=data max_match=100 "<query>(?<query>\p{Any}+?)<\/query>" \
| rex field=data max_match=100 "<param name=\"search\">(?<param>\p{Any}+?)<\/param>" \
| rex field=data max_match=100 "<searchString>(?<searchString>\p{Any}+?)<\/searchString>" \
| rex field=data max_match=100 "[<]search\s(base|id)=\"(?<base1>\w+)" \
| rex field=data max_match=100 "[<]search\sdepends=.*id=\"(?<base2>\w+)" \
| eval author = if(author="nobody", "system", author) , \
    dashboard_size = len(data) , \
    location = if(match(id, "^apps"), id, "users/" . id) ,\
    base = mvsort(mvdedup(mvappend(base1, base2))) ,\
    BaseSearch = if(isnull(base), "Basesearch_Not_Used!", base),\
    search = trim(mvsort(mvdedup(mvappend(query, param, searchString)))) \
| rex field=search mode=sed "s/\s{2,}/ /g" \
| rex field=search mode=sed "s/\&lt;=/<=/g" \
| rex field=search mode=sed "s/\&gt;=/>=/g" \
| rex field=search mode=sed "s/\&lt;/</g" \
| rex field=search mode=sed "s/\&gt;/>/g" \
| rex field=search mode=sed "s/^\s*<!\[CDATA\[\s*|\s*\]\]>$//g" \
| eval search = if( match(search, "^\s+$") OR search="", null(), search ) \
| rex field=search mode=sed "s/^\s*[\r\n]+//g" \
| `strptime_format(updated)` \
| `get_shcluster_label(Splunk_Instance)` \
| `get_lookup_reference(search)` \
| `get_macro_reference(search)` \
| `get_datamodel_reference(search)` \
| `get_index_reference(search)` \
| `get_sourcetype_reference(search)` \
| `get_source_reference(search)` \
| `get_eventtype_reference(search)` \
| `get_rest_reference(search)` \
| `get_report_reference(data)` \
| `get_dashboard_reference(data)` \
| fields shcluster_label Splunk_Instance app sharing title label description type dashboard_size author location updated Report_Reference Dashboard_Reference Lookup_Reference Datamodel_Reference Macro_Reference Index_Reference Sourcetype_Reference Source_Reference Eventtype_Reference Rest_Reference search BaseSearch acl_perms_read acl_perms_write \
| stats \
    values(Lookup_Reference) AS Lookup_Reference \
    values(Macro_Reference) AS Macro_Reference\
    values(Datamodel_Reference) AS Datamodel_Reference \
    values(Index_Reference) AS Index_Reference\
    values(Sourcetype_Reference) AS Sourcetype_Reference\
    values(Source_Reference) AS Source_Reference\
    values(Eventtype_Reference) AS Eventtype_Reference\
    values(Rest_Reference) AS Rest_Reference \
    values(Report_Reference) AS Report_Reference \
    values(Dashboard_Reference) AS Dashboard_Reference\
    values(Splunk_Instance) AS Splunk_Instance \
    values(search) AS search \
    values(BaseSearch) AS BaseSearch\
    values(acl_perms_read) AS acl_perms_read\
    values(acl_perms_write) AS acl_perms_write\
    last(*) AS * \
    BY shcluster_label app title \
| table shcluster_label Splunk_Instance app sharing title label description type dashboard_size author location updated Report_Reference Dashboard_Reference Lookup_Reference Datamodel_Reference Macro_Reference Index_Reference Sourcetype_Reference Source_Reference Eventtype_Reference Rest_Reference search BaseSearch acl_perms_read acl_perms_write \
| outputlookup splunk_rest_data_ui_views_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_saved_searches_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 20 5 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/saved/searches splunk_server_group=dmc_group_search_head timeout=0 earliest_time=-1d@d latest_time=-0d@d \
    `gmc_comment("| eval savedsearch_type=if((NOT 'action'=="*" AND NOT alert.track=="*" AND NOT alert_condition=="*" AND 'alert_type'=="always"),"report","alert") ")` \
| eval savedsearch_type=if('alert.track'=="1","alert","report") \
| rename splunk_server As Splunk_Instance eai:acl.app As app title As savedsearch_name description As description author As author disabled As disabled is_scheduled As is_scheduled eai:acl.sharing As sharing cron_schedule As cron_schedule is_visible As is_visible max_concurrent As max_concurrent next_scheduled_time As next_scheduled_time realtime_schedule As realtime_schedule run_n_times As run_n_times run_on_startup As run_on_startup schedule_priority As schedule_priority schedule_window As schedule_window scheduled_times As scheduled_times updated As updated allow_skew As allow_skew eai:acl.perms.read As acl_perms_read eai:acl.perms.write As acl_perms_write action.correlationsearch.enabled As correlationsearch_enabled action.correlationsearch.label As correlationsearch_label action.email As email action.email.message.alert As email_message_alert action.email.message.report As email_message_report action.email.to As email_to action.indicator As indicator action.indicator._itsi_base_search_id As itsi_base_search_id action.indicator._itsi_kpi_id As itsi_kpi_id action.indicator._itsi_service_id As itsi_service_id action.itsi_event_generator As itsi_eg action.itsi_event_generator.param.description As itsi_eg_param_description action.itsi_event_generator.param.drilldown_search_earliest_offset As itsi_eg_param_drilldown_search_earliest_offset action.itsi_event_generator.param.drilldown_search_latest_offset As itsi_eg_param_drilldown_search_latest_offset action.itsi_event_generator.param.drilldown_search_search As itsi_eg_param_drilldown_search_search action.itsi_event_generator.param.drilldown_search_title As itsi_eg_param_drilldown_search_title action.itsi_event_generator.param.drilldown_title As itsi_eg_param_drilldown_title action.itsi_event_generator.param.drilldown_uri As itsi_eg_param_drilldown_uri action.itsi_event_generator.param.entity_lookup_field As itsi_eg_param_entity_lookup_field action.itsi_event_generator.param.event_identifier_fields As itsi_eg_param_event_identifier_fields action.itsi_event_generator.param.meta_data As itsi_eg_param_meta_data action.itsi_event_generator.param.owner As itsi_eg_param_owner action.itsi_event_generator.param.search_type As itsi_eg_param_search_type action.itsi_event_generator.param.service_ids As itsi_eg_param_service_ids action.itsi_event_generator.param.severity As itsi_eg_param_severity action.itsi_event_generator.param.status As itsi_eg_param_status action.itsi_event_generator.param.title As itsi_eg_param_title action.keyindicator As kpi action.keyindicator.delta As kpi_delta action.keyindicator.drilldown_uri As kpi_drilldown_uri action.keyindicator.group.0.name As kpi_group_0_name action.keyindicator.group.0.order As kpi_group_0_order action.keyindicator.group.1.name As kpi_group_1_name action.keyindicator.group.1.order As kpi_group_1_order action.keyindicator.invert As kpi_invert action.keyindicator.subtitle As kpi_subtitle action.keyindicator.threshold As kpi_threshold action.keyindicator.title As kpi_title action.keyindicator.value As kpi_value action.keyindicator.value_suffix As kpi_value_suffix action.makestreams.param.verbose As makestreams_param_verbose action.nbtstat.param.verbose As nbtstat_param_verbose action.nslookup.param.verbose As nslookup_param_verbose action.output_message As output_message action.output_message.param.fields As output_message_param_fields action.output_message.param.msgid As output_message_param_msgid action.output_message.param.name As output_message_param_name action.output_message.param.purge As output_message_param_purge action.outputtelemetry As outputtelemetry action.populate_lookup As populate_lookup action.populate_lookup.dest As populate_lookup_dest action.script As script action.summary_index As summary_index action.summary_index._name As summary_index_name action.webhook As webhook action.webhook.param.url As webhook_param_url actions As actions alert_comparator As alert_comparator alert_condition As alert_condition alert_threshold As alert_threshold alert_type As alert_type alert.severity As alert_severity alert.suppress As alert_suppress alert.suppress.fields As alert_suppress_fields alert.suppress.period As alert_suppress_period alert.track As alert_track auto_summarize As auto_summarize auto_summarize.cron_schedule As auto_summarize_cron_schedule auto_summarize.dispatch.earliest_time As auto_summarize_dispatch_earliest_time auto_summarize.dispatch.latest_time As auto_summarize_dispatch_latest_time auto_summarize.max_concurrent As auto_summarize_max_concurrent dispatch.auto_cancel As dispatch_auto_cancel dispatch.auto_pause As dispatch_auto_pause dispatch.buckets As dispatch_buckets dispatch.earliest_time As dispatch_earliest_time dispatch.index_earliest As dispatch_index_earliest dispatch.index_latest As dispatch_index_latest dispatch.indexedRealtime As dispatch_indexedrealtime dispatch.indexedRealtimeOffset As dispatch_indexedrealtimeoffset dispatch.latest_time As dispatch_latest_time dispatch.ttl As dispatch_ttl dispatchAs As dispatch_as search As search action.logevent As logevent\
    action.logevent.param.event As logevent_param_event action.lookup As lookup action.lookup.append As lookup_append action.lookup.filename As lookup_filename action.script.filename As script_filename alert.expires As alert_expires \
| fields Splunk_Instance app savedsearch_name savedsearch_type description author disabled is_scheduled sharing cron_schedule is_visible max_concurrent next_scheduled_time realtime_schedule run_n_times run_on_startup schedule_priority schedule_window scheduled_times updated allow_skew acl_perms_read acl_perms_write correlationsearch_enabled correlationsearch_label email email_message_alert email_message_report email_to indicator itsi_base_search_id itsi_kpi_id itsi_service_id itsi_eg itsi_eg_param_description itsi_eg_param_drilldown_search_earliest_offset itsi_eg_param_drilldown_search_latest_offset itsi_eg_param_drilldown_search_search itsi_eg_param_drilldown_search_title itsi_eg_param_drilldown_title itsi_eg_param_drilldown_uri itsi_eg_param_entity_lookup_field itsi_eg_param_event_identifier_fields itsi_eg_param_meta_data itsi_eg_param_owner itsi_eg_param_search_type itsi_eg_param_service_ids itsi_eg_param_severity itsi_eg_param_status itsi_eg_param_title kpi kpi_delta kpi_drilldown_uri kpi_group_0_name kpi_group_0_order kpi_group_1_name kpi_group_1_order kpi_invert kpi_subtitle kpi_threshold kpi_title kpi_value kpi_value_suffix makestreams_param_verbose nbtstat_param_verbose nslookup_param_verbose output_message output_message_param_fields output_message_param_msgid output_message_param_name output_message_param_purge outputtelemetry populate_lookup populate_lookup_dest script summary_index summary_index_name webhook webhook_param_url actions alert_comparator alert_condition alert_threshold alert_type alert_severity alert_suppress alert_suppress_fields alert_suppress_period alert_track auto_summarize auto_summarize_cron_schedule auto_summarize_dispatch_earliest_time auto_summarize_dispatch_latest_time auto_summarize_max_concurrent dispatch_auto_cancel dispatch_auto_pause dispatch_buckets dispatch_earliest_time dispatch_index_earliest dispatch_index_latest dispatch_indexedrealtime dispatch_indexedrealtimeoffset dispatch_latest_time dispatch_ttl dispatch_as search logevent logevent_param_event lookup lookup_append lookup_filename script_filename alert_expires \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| `strptime_format(updated)` \
| `get_shcluster_label(Splunk_Instance)` \
| `get_lookup_reference(search)` \
| `get_macro_reference(search)` \
| `get_datamodel_reference(search)` \
| `get_index_reference(search)` \
| `get_sourcetype_reference(search)` \
| `get_source_reference(search)` \
| `get_eventtype_reference(search)` \
| `get_rest_reference(search)` \
| eval author = if(author="nobody", "system", author) ,\
    next_scheduled_time=strptime(next_scheduled_time,"%Y-%m-%d %H:%M:%S %Z") \
| makemv delim="," action_correlationsearch_related_searches \
| rex field=action_correlationsearch_related_searches mode=sed "s/\[\"|\"\]|\[|\]|\"//g" \
| rex field=search "\|\s*collect\s+index=(?<action_summary_index_name>.*?)\s" \
| eval \
    action_correlationsearch_related_searches = mvdedup(mvsort(trim(action_correlationsearch_related_searches))),\
    action_summary_index = if(match(search, "\|\s*collect\s+"), 1, action_summary_index),\
    action_summary_index_name = trim(action_summary_index_name) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(scheduled_times) as scheduled_times\
    values(Lookup_Reference) AS Lookup_Reference \
    values(Datamodel_Reference) AS Datamodel_Reference \
    values(Macro_Reference) AS Macro_Reference\
    values(Index_Reference) AS Index_Reference\
    values(Sourcetype_Reference) AS Sourcetype_Reference\
    values(Source_Reference) AS Source_Reference\
    values(Eventtype_Reference) AS Eventtype_Reference\
    values(Rest_Reference) AS Rest_Reference \
    values(action_correlationsearch_related_searches) AS action_correlationsearch_related_searches\
    values(acl_perms_read) AS acl_perms_read values(acl_perms_write) AS acl_perms_write\
    last(*) AS * \
    BY shcluster_label app savedsearch_name \
| eval scheduled_times = mvindex(scheduled_times, 0, 4) \
| table shcluster_label Splunk_Instance app savedsearch_name savedsearch_type description author disabled is_scheduled sharing cron_schedule is_visible max_concurrent next_scheduled_time realtime_schedule run_n_times run_on_startup schedule_priority schedule_window scheduled_times updated allow_skew acl_perms_read acl_perms_write correlationsearch_enabled correlationsearch_label email email_message_alert email_message_report email_to indicator itsi_base_search_id itsi_kpi_id itsi_service_id itsi_eg itsi_eg_param_description itsi_eg_param_drilldown_search_earliest_offset itsi_eg_param_drilldown_search_latest_offset itsi_eg_param_drilldown_search_search itsi_eg_param_drilldown_search_title itsi_eg_param_drilldown_title itsi_eg_param_drilldown_uri itsi_eg_param_entity_lookup_field itsi_eg_param_event_identifier_fields itsi_eg_param_meta_data itsi_eg_param_owner itsi_eg_param_search_type itsi_eg_param_service_ids itsi_eg_param_severity itsi_eg_param_status itsi_eg_param_title kpi kpi_delta kpi_drilldown_uri kpi_group_0_name kpi_group_0_order kpi_group_1_name kpi_group_1_order kpi_invert kpi_subtitle kpi_threshold kpi_title kpi_value kpi_value_suffix makestreams_param_verbose nbtstat_param_verbose nslookup_param_verbose output_message output_message_param_fields output_message_param_msgid output_message_param_name output_message_param_purge outputtelemetry populate_lookup populate_lookup_dest script summary_index summary_index_name webhook webhook_param_url actions alert_comparator alert_condition alert_threshold alert_type alert_severity alert_suppress alert_suppress_fields alert_suppress_period alert_track auto_summarize auto_summarize_cron_schedule auto_summarize_dispatch_earliest_time auto_summarize_dispatch_latest_time auto_summarize_max_concurrent dispatch_auto_cancel dispatch_auto_pause dispatch_buckets dispatch_earliest_time dispatch_index_earliest dispatch_index_latest dispatch_indexedrealtime dispatch_indexedrealtimeoffset dispatch_latest_time dispatch_ttl dispatch_as search logevent logevent_param_event lookup lookup_append lookup_filename script_filename alert_expires Lookup_Reference Datamodel_Reference Macro_Reference Index_Reference Sourcetype_Reference Source_Reference Eventtype_Reference Rest_Reference \
| outputlookup splunk_rest_saved_searches_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_data_props_calcfields_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 20 4 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/data/props/calcfields splunk_server_group=dmc_group_search_head timeout=0 \
| rename eai:acl.* as *, field.* as * , splunk_server AS Splunk_Instance , perms.read As acl_perms_read , perms.write As acl_perms_write \
| eval author = if(author="nobody", "system", author) \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| fields shcluster_label Splunk_Instance app sharing stanza name value author updated acl_perms_read acl_perms_write \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(acl_perms_read) AS acl_perms_read \
    values(acl_perms_write) AS acl_perms_write \
    last(*) as * \
    by shcluster_label app stanza name \
| table shcluster_label Splunk_Instance app sharing stanza name value author updated acl_perms_read acl_perms_write \
| outputlookup splunk_rest_data_props_calcfields_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_data_props_extractions_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 30 4 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/data/props/extractions splunk_server_group=dmc_group_search_head timeout=0 \
| rename eai:acl.* as * , splunk_server AS Splunk_Instance , perms.read As acl_perms_read , perms.write As acl_perms_write \
| eval author = if(author="nobody", "system", author) \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| fields shcluster_label Splunk_Instance app sharing stanza attribute value author type updated acl_perms_read acl_perms_write \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(acl_perms_read) AS acl_perms_read \
    values(acl_perms_write) AS acl_perms_write \
    last(*) as * \
    by shcluster_label app stanza attribute \
| table shcluster_label Splunk_Instance app sharing stanza attribute value author type updated acl_perms_read acl_perms_write \
| outputlookup splunk_rest_data_props_extractions_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_data_props_fieldaliases_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 40 4 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/data/props/fieldaliases splunk_server_group=dmc_group_search_head timeout=0 \
| rename eai:acl.* as *, field.* as * , splunk_server AS Splunk_Instance , perms.read As acl_perms_read , perms.write As acl_perms_write \
| eval author = if(author="nobody", "system", author) \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| fields shcluster_label Splunk_Instance title app author attribute sharing stanza updated value acl_perms_read acl_perms_write \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(acl_perms_read) AS acl_perms_read \
    values(acl_perms_write) AS acl_perms_write \
    last(*) as * \
    by shcluster_label app stanza attribute \
| table shcluster_label Splunk_Instance app author stanza attribute value sharing updated acl_perms_read acl_perms_write \
| outputlookup splunk_rest_data_props_fieldaliases_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_data_transforms_extractions_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 0 5 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/data/transforms/extractions splunk_server_group=dmc_group_search_head timeout=0 \
| rename eai:acl.* as *, field.* as * , splunk_server AS Splunk_Instance , perms.read As acl_perms_read , perms.write As acl_perms_write \
| eval Type = case ( isnotnull(DELIMS), "delimiter-based", isnotnull(REGEX), "regex-based", true(), Type) \
| eval author = if(author="nobody", "system", author) \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| fields shcluster_label Splunk_Instance title disabled Type app author FORMAT REGEX DELIMS CLEAN_KEYS DEST_KEY FIELDS MV_ADD REPEAT_MATCH SOURCE_KEY WRITE_META sharing updated acl_perms_read acl_perms_write \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(acl_perms_read) AS acl_perms_read \
    values(acl_perms_write) AS acl_perms_write \
    last(*) as * \
    by shcluster_label app title \
| table shcluster_label Splunk_Instance title disabled Type app author FORMAT REGEX DELIMS CLEAN_KEYS DEST_KEY FIELDS MV_ADD REPEAT_MATCH SOURCE_KEY WRITE_META sharing updated acl_perms_read acl_perms_write \
| outputlookup splunk_rest_data_transforms_extractions_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_admin_eventtypes_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 20 2 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/admin/eventtypes splunk_server_group=dmc_group_search_head timeout=0 \
| rename "eai:acl.*" as "*", "eai:*" as "*" , splunk_server AS Splunk_Instance , perms.read As acl_perms_read , perms.write As acl_perms_write \
| eval author = if(author="nobody", "system", author) \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| fields shcluster_label Splunk_Instance app sharing author title description disabled color priority tags search updated acl_perms_read acl_perms_write \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(acl_perms_read) AS acl_perms_read \
    values(acl_perms_write) AS acl_perms_write \
    values(tags) AS tags\
    last(*) as * \
    by shcluster_label app sharing title \
| eval tags = mvjoin(tags, ",") \
| table shcluster_label Splunk_Instance app sharing title author description disabled color priority tags search updated acl_perms_read acl_perms_write \
| outputlookup splunk_rest_admin_eventtypes_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_admin_lookup_table_files_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 30 2 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/admin/lookup-table-files splunk_server_group=dmc_group_search_head timeout=0 \
| rename eai:acl.* AS * , eai:* AS * \
| rename appName AS app, title AS Filename, splunk_server AS Splunk_Instance, data AS Lookup_File_Path , perms.read As acl_perms_read , perms.write As acl_perms_write \
| eval author = if(author="nobody", "system", author) \
| fields Filename author disabled app sharing Splunk_Instance updated Lookup_File_Path \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| fields shcluster_label Splunk_Instance Filename author disabled app sharing Splunk_Instance updated Lookup_File_Path acl_perms_read acl_perms_write \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| stats\
    values(Splunk_Instance) AS Splunk_Instance \
    values(acl_perms_read) AS acl_perms_read \
    values(acl_perms_write) AS acl_perms_write \
    values(author) AS author \
    last(*) AS * \
    BY shcluster_label app sharing Filename \
| table shcluster_label Splunk_Instance app sharing author disabled updated Filename Lookup_File_Path acl_perms_read acl_perms_write \
| outputlookup splunk_rest_admin_lookup_table_files_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_admin_transforms_lookup_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 50 2 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/admin/transforms-lookup splunk_server_group=dmc_group_search_head timeout=0 \
| rename eai:acl.* AS * , eai:* AS * \
| rename appName AS app, title AS Lookup, splunk_server AS Splunk_Instance, data AS Lookup_File_Path, filename AS Filename fields_list AS Fields_List type AS Type match_type AS Match_Type replicate AS Replicate allow_caching AS Allow_Caching collection AS Collection filter AS Filter index_fields_list AS Index_Fields_List min_matches AS Min_Matches max_matches AS Max_Matches , perms.read As acl_perms_read , perms.write As acl_perms_write \
| eval author = if(author="nobody", "system", author) \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| fields shcluster_label Splunk_Instance app sharing Lookup Filename Type Collection updated disabled author Match_Type Replicate Allow_Caching Filter Index_Fields_List Min_Matches Max_Matches Fields_List case_sensitive_match acl_perms_read acl_perms_write \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(acl_perms_read) AS acl_perms_read \
    values(acl_perms_write) AS acl_perms_write \
    lASt(*) AS * \
    BY shcluster_label app Lookup sharing author \
| table shcluster_label Splunk_Instance app Lookup author sharing Filename Type Collection updated disabled Match_Type Replicate Allow_Caching Filter Index_Fields_List Min_Matches Max_Matches Fields_List case_sensitive_match acl_perms_read acl_perms_write \
| outputlookup splunk_rest_admin_transforms_lookup_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_data_props_lookups_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 50 4 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/data/props/lookups splunk_server_group=dmc_group_search_head timeout=0 \
| rename eai:acl.* as * , splunk_server AS Splunk_Instance , perms.read As acl_perms_read , perms.write As acl_perms_write \
| eval author = if(author="nobody", "system", author) \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| fields shcluster_label Splunk_Instance app sharing stanza attribute transform overwrite value author updated acl_perms_read acl_perms_write \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(acl_perms_read) AS acl_perms_read \
    values(acl_perms_write) AS acl_perms_write \
    last(*) as * \
    by shcluster_label app stanza attribute \
| table shcluster_label Splunk_Instance app sharing stanza attribute transform overwrite value author updated acl_perms_read acl_perms_write \
| outputlookup splunk_rest_data_props_lookups_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_data_macros_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 0 4 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/data/macros splunk_server_group=dmc_group_search_head timeout=0 \
| rename eai:acl.* as * , splunk_server AS Splunk_Instance , perms.read As acl_perms_read , perms.write As acl_perms_write \
| fields Splunk_Instance app title disabled definition args sharing author description updated errormsg iseval validation acl_perms_read acl_perms_write \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| eval author = if(author="nobody", "system", author) \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(acl_perms_read) AS acl_perms_read \
    values(acl_perms_write) AS acl_perms_write \
    last(*) as * \
    by shcluster_label app title \
| table shcluster_label Splunk_Instance title definition args app sharing author description updated disabled errormsg iseval validation acl_perms_read acl_perms_write \
| outputlookup splunk_rest_data_macros_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count

[splunk_rest_data_models_sh_kv_store_lookup_gen]
alert.track = 0
allow_skew = 0
cron_schedule = 10 4 * * *
dispatch.earliest_time = -1s
dispatch.latest_time = now
enableSched = 1
schedule_window = 0
search = | rest /servicesNS/-/-/data/models splunk_server_group=dmc_group_search_head timeout=0 \
| rename eai:acl.* as *, field.* as * , splunk_server AS Splunk_Instance , acceleration.* AS * , perms.read As acl_perms_read , perms.write As acl_perms_write \
| eval author = if(author="nobody", "system", author) \
| `get_shcluster_label(Splunk_Instance)` \
| `strptime_format(updated)` \
| fields shcluster_label Splunk_Instance Splunk_Roles disabled title app sharing author acceleration allow_old_summaries allow_skew cron_schedule earliest_time manual_rebuilds max_concurrent max_time poll_buckets_until_maxtime schedule_priority sharing tags_whitelist updated acl_perms_read acl_perms_write \
| eval acl_perms_read=if(match(acl_perms_read, "\*"), "Everyone", acl_perms_read), acl_perms_write=if(match(acl_perms_write, "\*"), "Everyone", acl_perms_write) \
| stats \
    values(Splunk_Instance) AS Splunk_Instance \
    values(acl_perms_read) AS acl_perms_read \
    values(acl_perms_write) AS acl_perms_write \
    last(*) as * \
    by shcluster_label app title \
| table shcluster_label Splunk_Instance disabled title app sharing author acceleration allow_old_summaries allow_skew cron_schedule earliest_time manual_rebuilds max_concurrent max_time poll_buckets_until_maxtime updated acl_perms_read acl_perms_write \
| outputlookup splunk_rest_data_models_sh_kv_store_lookup createinapp=true create_empty=true override_if_empty=false \
| stats count
