
[gmc_convert_runtime(1)]
description = Converts time in seconds to human-readable format
args = runtime
definition = eval $runtime$=case(round($runtime$ / (3600*24) - 0.5) > 0, round($runtime$ / (3600*24)- 0.5)."d ".round(($runtime$ % (3600*24)) / 3600 - 0.5)."h ".round(($runtime$ % 3600) / 60 - 0.5)."min ".round($runtime$ % 60, 2)."s",round(($runtime$ % (3600*24)) / 3600 - 0.5) > 0,round(($runtime$ % (3600*24)) / 3600 - 0.5)."h ".round(($runtime$ % 3600) / 60 - 0.5)."min ".round($runtime$ % 60, 2)."s",round(($runtime$ % 3600) / 60 - 0.5) > 0, round(($runtime$ % 3600) / 60 - 0.5)."min ".round($runtime$ % 60, 2)."s", 1 = 1, round($runtime$ % 60, 2)."s")

# Gather Information Macros

[get_saved_searches_info(1)]
description = Retrieves information about Scheduled Searches from the splunk_rest_saved_searches_sh_kv_store KV Store Lookup Table (match by savedsearch only)
args = Savedsearch_Name
definition = lookup splunk_rest_saved_searches_sh_kv_store_lookup savedsearch_name AS $Savedsearch_Name$ OUTPUTNEW savedsearch_type description author disabled is_scheduled sharing cron_schedule is_visible max_concurrent next_scheduled_time realtime_schedule run_n_times run_on_startup schedule_priority schedule_window scheduled_times updated allow_skew acl_perms_read acl_perms_write correlationsearch_enabled correlationsearch_label email email_message_alert email_message_report email_to indicator itsi_base_search_id itsi_kpi_id itsi_service_id itsi_eg itsi_eg_param_description itsi_eg_param_drilldown_search_earliest_offset itsi_eg_param_drilldown_search_latest_offset itsi_eg_param_drilldown_search_search itsi_eg_param_drilldown_search_title itsi_eg_param_drilldown_title itsi_eg_param_drilldown_uri itsi_eg_param_entity_lookup_field itsi_eg_param_event_identifier_fields itsi_eg_param_meta_data itsi_eg_param_owner itsi_eg_param_search_type itsi_eg_param_service_ids itsi_eg_param_severity itsi_eg_param_status itsi_eg_param_title kpi kpi_delta kpi_drilldown_uri kpi_group_0_name kpi_group_0_order kpi_group_1_name kpi_group_1_order kpi_invert kpi_subtitle kpi_threshold kpi_title kpi_value kpi_value_suffix makestreams_param_verbose nbtstat_param_verbose nslookup_param_verbose output_message output_message_param_fields output_message_param_msgid output_message_param_name output_message_param_purge outputtelemetry populate_lookup populate_lookup_dest script summary_index summary_index_name webhook webhook_param_url actions alert_comparator alert_condition alert_threshold alert_type alert_severity alert_suppress alert_suppress_fields alert_suppress_period alert_track auto_summarize auto_summarize_cron_schedule auto_summarize_dispatch_earliest_time auto_summarize_dispatch_latest_time auto_summarize_max_concurrent dispatch_auto_cancel dispatch_auto_pause dispatch_buckets dispatch_earliest_time dispatch_index_earliest dispatch_index_latest dispatch_indexedrealtime dispatch_indexedrealtimeoffset dispatch_latest_time dispatch_ttl dispatch_as search Lookup_Reference Datamodel_Reference Macro_Reference Index_Reference Sourcetype_Reference Source_Reference Eventtype_Reference Rest_Reference\
\
| eval description=mvdedup(description), savedsearch_type=mvdedup(savedsearch_type), is_scheduled=mvdedup(is_scheduled), cron_schedule=mvdedup(cron_schedule), auto_summarize=mvdedup(auto_summarize), dispatch_earliest_time=mvdedup(dispatch_earliest_time), dispatch_latest_time=mvdedup(dispatch_latest_time), schedule_priority=mvdedup(schedule_priority), max_concurrent=mvdedup(max_concurrent), schedule_window=mvdedup(schedule_window), allow_skew=mvdedup(allow_skew), realtime_schedule=mvdedup(realtime_schedule), run_n_times=mvdedup(run_n_times) , run_on_startup=mvdedup(run_on_startup), Lookup_Reference=mvdedup(Lookup_Reference), Datamodel_Reference=mvdedup(Datamodel_Reference) , savedsearch_search=mvdedup(savedsearch_search), email_to=mvdedup(email_to)\
| fillnull value="0" disabled allow_skew schedule_window run_on_startup auto_summarize run_n_times is_scheduled summary_index\
| fillnull value="1" realtime_schedule max_concurrent is_visible auto_summarize_max_concurrent\
| fillnull value="default" schedule_priority\
| fillnull value="no-lookup-reference" Lookup_Reference \
| fillnull value="no-macro-reference" Macro_Reference \
| fillnull value="no-datamodel-reference" Datamodel_Reference \
| fillnull value="no-index-reference" Index_Reference \
| fillnull value="no-sourcetype-reference" Sourcetype_Reference \
| fillnull value="no-source-reference" Source_Reference \
| fillnull value="no-eventtype-reference" Eventtype_Reference \
| fillnull value="no-report-reference" Report_Reference \
| fillnull value="no-dashboard-reference" Dashboard_Reference\
| fillnull value="no-rest-reference" Rest_Reference

[get_saved_searches_info(2)]
description = Retrieves information about Scheduled Searches from the splunk_rest_saved_searches_sh_kv_store KV Store Lookup Table (match by SH & savedsearch)
args = shcluster_label,Savedsearch_Name
definition = eval $shcluster_label$=lower($shcluster_label$)\
| lookup splunk_rest_saved_searches_sh_kv_store_lookup shcluster_label AS $shcluster_label$ savedsearch_name AS $Savedsearch_Name$ OUTPUTNEW savedsearch_type description author disabled is_scheduled sharing cron_schedule is_visible max_concurrent next_scheduled_time realtime_schedule run_n_times run_on_startup schedule_priority schedule_window scheduled_times updated allow_skew acl_perms_read acl_perms_write correlationsearch_enabled correlationsearch_label email email_message_alert email_message_report email_to indicator itsi_base_search_id itsi_kpi_id itsi_service_id itsi_eg itsi_eg_param_description itsi_eg_param_drilldown_search_earliest_offset itsi_eg_param_drilldown_search_latest_offset itsi_eg_param_drilldown_search_search itsi_eg_param_drilldown_search_title itsi_eg_param_drilldown_title itsi_eg_param_drilldown_uri itsi_eg_param_entity_lookup_field itsi_eg_param_event_identifier_fields itsi_eg_param_meta_data itsi_eg_param_owner itsi_eg_param_search_type itsi_eg_param_service_ids itsi_eg_param_severity itsi_eg_param_status itsi_eg_param_title kpi kpi_delta kpi_drilldown_uri kpi_group_0_name kpi_group_0_order kpi_group_1_name kpi_group_1_order kpi_invert kpi_subtitle kpi_threshold kpi_title kpi_value kpi_value_suffix makestreams_param_verbose nbtstat_param_verbose nslookup_param_verbose output_message output_message_param_fields output_message_param_msgid output_message_param_name output_message_param_purge outputtelemetry populate_lookup populate_lookup_dest script summary_index summary_index_name webhook webhook_param_url actions alert_comparator alert_condition alert_threshold alert_type alert_severity alert_suppress alert_suppress_fields alert_suppress_period alert_track auto_summarize auto_summarize_cron_schedule auto_summarize_dispatch_earliest_time auto_summarize_dispatch_latest_time auto_summarize_max_concurrent dispatch_auto_cancel dispatch_auto_pause dispatch_buckets dispatch_earliest_time dispatch_index_earliest dispatch_index_latest dispatch_indexedrealtime dispatch_indexedrealtimeoffset dispatch_latest_time dispatch_ttl dispatch_as search Lookup_Reference Datamodel_Reference Macro_Reference Index_Reference Sourcetype_Reference Source_Reference Eventtype_Reference Rest_Reference\
\
| eval description=mvdedup(description), savedsearch_type=mvdedup(savedsearch_type), is_scheduled=mvdedup(is_scheduled), cron_schedule=mvdedup(cron_schedule), auto_summarize=mvdedup(auto_summarize), dispatch_earliest_time=mvdedup(dispatch_earliest_time), dispatch_latest_time=mvdedup(dispatch_latest_time), schedule_priority=mvdedup(schedule_priority), max_concurrent=mvdedup(max_concurrent), schedule_window=mvdedup(schedule_window), allow_skew=mvdedup(allow_skew), realtime_schedule=mvdedup(realtime_schedule), run_n_times=mvdedup(run_n_times) , run_on_startup=mvdedup(run_on_startup), Lookup_Reference=mvdedup(Lookup_Reference), Datamodel_Reference=mvdedup(Datamodel_Reference) , savedsearch_search=mvdedup(savedsearch_search), email_to=mvdedup(email_to)\
| fillnull value="0" disabled allow_skew schedule_window run_on_startup auto_summarize run_n_times is_scheduled summary_index\
| fillnull value="1" realtime_schedule max_concurrent is_visible auto_summarize_max_concurrent\
| fillnull value="default" schedule_priority\
| fillnull value="no-lookup-reference" Lookup_Reference\
| fillnull value="no-macro-reference" Macro_Reference\
| fillnull value="no-datamodel-reference" Datamodel_Reference\
| fillnull value="no-index-reference" Index_Reference\
| fillnull value="no-sourcetype-reference" Sourcetype_Reference\
| fillnull value="no-source-reference" Source_Reference\
| fillnull value="no-eventtype-reference" Eventtype_Reference\
| fillnull value="no-report-reference" Report_Reference\
| fillnull value="no-dashboard-reference" Dashboard_Reference\
| fillnull value="no-rest-reference" Rest_Reference

[get_saved_searches_info(3)]
description = Retrieves information about Scheduled Searches from the splunk_rest_saved_searches_sh_kv_store KV Store Lookup Table (match by SH, App & savedsearch)
args = shcluster_label,App,Savedsearch_Name
definition = eval $shcluster_label$=lower($shcluster_label$)\
| lookup splunk_rest_saved_searches_sh_kv_store_lookup shcluster_label AS $shcluster_label$ app AS $App$ savedsearch_name AS $Savedsearch_Name$ OUTPUTNEW savedsearch_type description author disabled is_scheduled sharing cron_schedule is_visible max_concurrent next_scheduled_time realtime_schedule run_n_times run_on_startup schedule_priority schedule_window scheduled_times updated allow_skew acl_perms_read acl_perms_write correlationsearch_enabled correlationsearch_label email email_message_alert email_message_report email_to indicator itsi_base_search_id itsi_kpi_id itsi_service_id itsi_eg itsi_eg_param_description itsi_eg_param_drilldown_search_earliest_offset itsi_eg_param_drilldown_search_latest_offset itsi_eg_param_drilldown_search_search itsi_eg_param_drilldown_search_title itsi_eg_param_drilldown_title itsi_eg_param_drilldown_uri itsi_eg_param_entity_lookup_field itsi_eg_param_event_identifier_fields itsi_eg_param_meta_data itsi_eg_param_owner itsi_eg_param_search_type itsi_eg_param_service_ids itsi_eg_param_severity itsi_eg_param_status itsi_eg_param_title kpi kpi_delta kpi_drilldown_uri kpi_group_0_name kpi_group_0_order kpi_group_1_name kpi_group_1_order kpi_invert kpi_subtitle kpi_threshold kpi_title kpi_value kpi_value_suffix makestreams_param_verbose nbtstat_param_verbose nslookup_param_verbose output_message output_message_param_fields output_message_param_msgid output_message_param_name output_message_param_purge outputtelemetry populate_lookup populate_lookup_dest script summary_index summary_index_name webhook webhook_param_url actions alert_comparator alert_condition alert_threshold alert_type alert_severity alert_suppress alert_suppress_fields alert_suppress_period alert_track auto_summarize auto_summarize_cron_schedule auto_summarize_dispatch_earliest_time auto_summarize_dispatch_latest_time auto_summarize_max_concurrent dispatch_auto_cancel dispatch_auto_pause dispatch_buckets dispatch_earliest_time dispatch_index_earliest dispatch_index_latest dispatch_indexedrealtime dispatch_indexedrealtimeoffset dispatch_latest_time dispatch_ttl dispatch_as search Lookup_Reference Datamodel_Reference Macro_Reference Index_Reference Sourcetype_Reference Source_Reference Eventtype_Reference Rest_Reference\
\
| eval description=mvdedup(description), savedsearch_type=mvdedup(savedsearch_type), is_scheduled=mvdedup(is_scheduled), cron_schedule=mvdedup(cron_schedule), auto_summarize=mvdedup(auto_summarize), dispatch_earliest_time=mvdedup(dispatch_earliest_time), dispatch_latest_time=mvdedup(dispatch_latest_time), schedule_priority=mvdedup(schedule_priority), max_concurrent=mvdedup(max_concurrent), schedule_window=mvdedup(schedule_window), allow_skew=mvdedup(allow_skew), realtime_schedule=mvdedup(realtime_schedule), run_n_times=mvdedup(run_n_times) , run_on_startup=mvdedup(run_on_startup), Lookup_Reference=mvdedup(Lookup_Reference), Datamodel_Reference=mvdedup(Datamodel_Reference) , savedsearch_search=mvdedup(savedsearch_search), email_to=mvdedup(email_to)\
| fillnull value="0" disabled allow_skew schedule_window run_on_startup auto_summarize run_n_times is_scheduled summary_index\
| fillnull value="1" realtime_schedule max_concurrent is_visible auto_summarize_max_concurrent\
| fillnull value="default" schedule_priority\
| fillnull value="no-lookup-reference" Lookup_Reference\
| fillnull value="no-macro-reference" Macro_Reference\
| fillnull value="no-datamodel-reference" Datamodel_Reference\
| fillnull value="no-index-reference" Index_Reference\
| fillnull value="no-sourcetype-reference" Sourcetype_Reference\
| fillnull value="no-source-reference" Source_Reference\
| fillnull value="no-eventtype-reference" Eventtype_Reference\
| fillnull value="no-report-reference" Report_Reference\
| fillnull value="no-dashboard-reference" Dashboard_Reference\
| fillnull value="no-rest-reference" Rest_Reference

[get_saved_searches_usage(2)]
description = Retrieves Usage information from the Scheduled Searches tracking KV Store about Reports/Alerts (match by App & savedsearch)
args = app,Savedsearch_Name
definition = lookup splunk_index_internal_scheduler_jobs_tracker_sh_kv_store_lookup App AS $app$ Savedsearch_Name AS $Savedsearch_Name$ OUTPUTNEW User Scheduled_Time Priority Dispatch_Time Window_Time Earliest_Access Latest_Access Run_Time Result_Count\
\
| eval Days_Latest_Access = round((now() - Latest_Access) / 86400 , 0) \
\
| eval Days_Latest_Access=if(((Days_Latest_Access == "") OR isnull(Days_Latest_Access)),"9999999",Days_Latest_Access)\
\
| `strftime_format(Scheduled_Time)` \
| `strftime_format(Dispatch_Time)` \
| `strftime_format(Earliest_Access)`\
| `strftime_format(Latest_Access)`

[get_saved_searches_usage(3)]
description = Retrieves Usage information from the Scheduled Searches tracking KV Store about Reports/Alerts (match by SH, App & savedsearch)
args = shcluster_label,app,Savedsearch_Name
definition = lookup splunk_index_internal_scheduler_jobs_tracker_sh_kv_store_lookup shcluster_label AS $shcluster_label$ App AS $app$ Savedsearch_Name AS $Savedsearch_Name$ OUTPUTNEW User Scheduled_Time Priority Dispatch_Time Window_Time Earliest_Access Latest_Access Run_Time Result_Count\
\
| eval Days_Latest_Access = round((now() - Latest_Access) / 86400 , 0) \
\
| eval Days_Latest_Access=if(((Days_Latest_Access == "") OR isnull(Days_Latest_Access)),"9999999",Days_Latest_Access)\
\
| `strftime_format(Scheduled_Time)`\
| `strftime_format(Dispatch_Time)`\
| `strftime_format(Earliest_Access)`\
| `strftime_format(Latest_Access)`

[get_dashboards_info(1)]
description = Retrieves information about Dashboards from the splunk_rest_data_ui_views_sh_kv_store_lookup KV Store Lookup Table (match by Dashboard Name only)
args = Dashboard_Name
definition = lookup splunk_rest_data_ui_views_sh_kv_store_lookup title AS $Dashboard_Name$ OUTPUTNEW label description Report_Reference Dashboard_Reference Lookup_Reference Datamodel_Reference Macro_Reference Index_Reference Sourcetype_Reference Source_Reference Eventtype_Reference search BaseSearch

[get_dashboards_info(2)]
description = Retrieves information about Dashboards from the splunk_rest_data_ui_views_sh_kv_store_lookup KV Store Lookup Table (match by SH & Dashboard Name)
args = shcluster_label,Dashboard_Name
definition = eval $shcluster_label$=lower($shcluster_label$)\
| lookup splunk_rest_data_ui_views_sh_kv_store_lookup shcluster_label AS $shcluster_label$ title AS $Dashboard_Name$ OUTPUTNEW label description Report_Reference Dashboard_Reference Lookup_Reference Datamodel_Reference Macro_Reference Index_Reference Sourcetype_Reference Source_Reference Eventtype_Reference search BaseSearch

[get_dashboards_info(3)]
description = Retrieves information about Dashboards from the splunk_rest_data_ui_views_sh_kv_store_lookup KV Store Lookup Table (match by SH, App & Dashboard Name)
args = shcluster_label,App,Dashboard_Name
definition = eval $shcluster_label$=lower($shcluster_label$)\
| lookup splunk_rest_data_ui_views_sh_kv_store_lookup shcluster_label AS $shcluster_label$ app AS $App$ title AS $Dashboard_Name$ OUTPUTNEW label description Report_Reference Dashboard_Reference Lookup_Reference Datamodel_Reference Macro_Reference Index_Reference Sourcetype_Reference Source_Reference Eventtype_Reference search BaseSearch

[get_dashboards_usage(3)]
description = Retrieves Usage information from the Dashboards tracking KV Store about Dashboards (match by SH, App & savedsearch)
args = shcluster_label,app,Dashboard_Name
definition = lookup splunk_index_internal_web_access_tracker_sh_kv_store_lookup shcluster_label AS $shcluster_label$ App AS $app$ Dashboard_Name AS $Dashboard_Name$ OUTPUTNEW Splunk_Instance User Earliest_Access Latest_Access min_spent max_spent avg_spent\
| eval Days_Latest_Access = round((now() - Latest_Access) / 86400 , 0) \
| eval Days_Latest_Access=if(((Days_Latest_Access == "") OR isnull(Days_Latest_Access)),"9999999",Days_Latest_Access)\
| eval max_spent=max_spent/1000\
| `strftime_format(Earliest_Access)`\
| `strftime_format(Latest_Access)`

[get_identity_info(2)]
description = Retrieves information about Identities from the splunk_identities_kv_store_lookup KV Store Lookup Table
args = shcluster_label,identity
definition = lookup splunk_identities_kv_store_lookup shcluster_label As $shcluster_label$ identity As $identity$ OUTPUTNEW prefix,nick,first,last,suffix,email,phone,phone2,managedBy,priority,bunit,category,watchlist,startDate,endDate,work_city,work_country,work_lat,work_long,work_region,emp_cc,emp_dep,emp_floor,emp_lob,emp_loc,emp_name,emp_type,emp_status,emp_ttl,emp_tz,splunk_role_map,ldap_group_name,ldap_group_type,last_successful_login\
| eval identity_custom=if(match(author, "splunk-system-user|system"), "splunk-system-user",null())\
| `get_identity_custom_info(identity_custom)`\
| fillnull value="no-geo-info" work_city,work_country,work_region\
| fillnull value="undefined" emp_cc,emp_dep,emp_floor,emp_lob,emp_loc,emp_name,emp_type,emp_status,emp_ttl,emp_tz,managedBy,splunk_role_map,ldap_group_name,ldap_group_type,last_successful_login

[get_identity_info_simple(2)]
description = Retrieves limited information about Identities from the splunk_identities_kv_store_lookup KV Store Lookup Table
args = shcluster_label,identity
definition = lookup splunk_identities_kv_store_lookup shcluster_label As $shcluster_label$ identity as $identity$ OUTPUTNEW emp_name emp_ttl emp_dep emp_lob emp_cc emp_type emp_status\
| fillnull value="undefined" emp_cc,emp_dep,emp_lob,emp_name,emp_type,emp_status,emp_ttl

[get_identity_custom_info(1)]
description = Enriches the splunk_identities_kv_store_lookup KV Store Lookup Table with custom Identities data stored in the splunk_identities_custom_sh_csv_lookup Lookup Table
args = identity
definition = lookup splunk_identities_custom_sh_csv_lookup identity as $identity$ OUTPUT prefix,suffix,nick,first,last,emp_name,emp_ttl,emp_dep,emp_lob,emp_cc,email,work_city,work_region,work_country,emp_type,emp_status,phone,phone2,managedBy,priority,bunit,startDate,endDate,emp_loc,emp_floor,emp_tz,work_lat,work_long

[get_identity_usage(1)]
description = Retrieves information about Identities Activity from the splunk_index_audit_user_login_tracker_sh_kv_store_lookupK Tracking V Store Lookup Table
args = username
definition = lookup splunk_index_audit_user_login_tracker_sh_kv_store_lookup User AS $username$ OUTPUTNEW Earliest_Access Latest_Access Splunk_Instance Login_Source\
| `strftime_format(Earliest_Access)`\
| `strftime_format(Latest_Access)`

[get_dm_field(2)]
description = Retrieves Data for a single field from the GMC Data Model
args = dataset,field
definition = tstats SUMMARIESONLY=TRUE ALLOW_OLD_SUMMARIES=FALSE \
    count\
    FROM DATAMODEL=GMC\
    WHERE nodename=Search_Activity.$dataset$\
    BY Search_Activity.$dataset$.$field$\
| `drop_dm_object_name(Search_Activity.$dataset$)`\
| table $field$ count

[get_provenance_fields(1)]
description = Extracts Introspection Provenance Fields for Audit Search Activity Dashboard
args = provenance
definition = rex field=$provenance$ "(?<Provenance_Type>.*?):(?<Provenance_KO_Type>.*?):(?<Provenance_KO>.*?)$"\
| eval provenance_tmp=if(isnull(Provenance_Type), provenance, null())\
| rex field=provenance_tmp "(?<Provenance_Type>.*?):(?<Provenance_KO_Type>.*?)$"\
| eval provenance_tmp=if(isnull(Provenance_Type), provenance, null())\
| rex field=provenance_tmp "(?<Provenance_Type>.*?)$"\
| eval Dashboard_Name = if(Provenance_KO_Type="Dashboard", Provenance_KO, null() )\
| rex field=acceleration_id "_DM_(?<datamodel>.*)" \
| eval acceleration_id_report=if(type="report_acceleration", acceleration_id, null()) \
| eval datamodel_acceleration=if(provenance="summary_director", acceleration_id, null()) \
| rex field=acceleration_id_report "_(?<accelerated_report>\w+$)"\
| fields - acceleration_id_report datamodel_acceleration provenance_tmp

[get_instance_info(1)]
description = Retrieves information about Splunk Instances from the splunk_assets_kv_store_lookup KV Store Lookup Table
args = Splunk_Instance
definition = eval $Splunk_Instance$=lower($Splunk_Instance$)\
| lookup splunk_assets_kv_store_lookup host As $Splunk_Instance$ OUTPUTNEW host Splunk_Instance Splunk_Roles serverName host_short host_fqdn host_resolved host_ip mode guid version build os_name os_name_extended cpu_arch os_version os_build startup_time kvStoreStatus numberOfCores numberOfVirtualCores physicalMemoryMB rtsearch_enabled master_uri master_guid licenseState isForwarding isTrial license_labels transparent_hugepages_defrag transparent_hugepages_effective_state transparent_hugepages_enabled ulimits_core_file_size ulimits_cpu_time ulimits_data_file_size ulimits_data_segment_size ulimits_nice ulimits_open_files ulimits_resident_memory_size ulimits_stack_size ulimits_user_processes ulimits_virtual_address_space_size SPLUNK_DB SPLUNK_HOME appServerPorts dfsDisabled dfsMasterPort enableSplunkWebSSL httpport kvStoreDisabled kvStorePort mgmtHostPort minFreeSpace sessionTimeout startwebserver trustedIP\
| lookup splunk_assets_kv_store_lookup Splunk_Instance As $Splunk_Instance$ OUTPUTNEW Splunk_Instance host Splunk_Roles serverName host_short host_fqdn host_resolved host_ip mode guid version build os_name os_name_extended cpu_arch os_version os_build startup_time kvStoreStatus numberOfCores numberOfVirtualCores physicalMemoryMB rtsearch_enabled master_uri master_guid licenseState isForwarding isTrial license_labels transparent_hugepages_defrag transparent_hugepages_effective_state transparent_hugepages_enabled ulimits_core_file_size ulimits_cpu_time ulimits_data_file_size ulimits_data_segment_size ulimits_nice ulimits_open_files ulimits_resident_memory_size ulimits_stack_size ulimits_user_processes ulimits_virtual_address_space_size SPLUNK_DB SPLUNK_HOME appServerPorts dfsDisabled dfsMasterPort enableSplunkWebSSL httpport kvStoreDisabled kvStorePort mgmtHostPort minFreeSpace sessionTimeout startwebserver trustedIP\
| eval physicalMemoryGB=round(physicalMemoryMB / 1024, 2) \
| `strftime_format(startup_time)`

[get_instance_info_simple(1)]
description = Retrieves Limited information about Splunk Instances from the splunk_assets_kv_store_lookup KV Store Lookup Table
args = Splunk_Instance
definition = eval $Splunk_Instance$=lower($Splunk_Instance$)\
| lookup splunk_assets_kv_store_lookup host As $Splunk_Instance$ OUTPUTNEW Splunk_Instance Splunk_Roles serverName host_short host_fqdn host_resolved host_ip\
| lookup splunk_assets_kv_store_lookup Splunk_Instance As $Splunk_Instance$ OUTPUTNEW host Splunk_Roles serverName host_short host_fqdn host_resolved host_ip

[get_shcluster_info(1)]
description = get_shcluster_info
args = Splunk_Instance
definition = eval $Splunk_Instance$=lower($Splunk_Instance$)\
| lookup splunk_rest_shcluster_config_shc_kv_store_lookup Splunk_Instance AS $Splunk_Instance$ OUTPUTNEW shcluster_label mode conf_deploy_fetch_url adhoc_searchhead replication_factor replication_port replication_use_ssl async_replicate_on_proxy register_replication_address captain_is_adhoc_searchhead decommission_search_jobs_wait_secs dynamic_captain heartbeat_period manual_detention max_peer_rep_load percent_peers_to_restart ping_flag preferred_captain quiet_period rolling_restart cxn_timeout heartbeat_timeout rcv_timeout send_timeout rep_cxn_timeout rep_max_rcv_timeout rep_max_send_timeout rep_rcv_timeout rep_send_timeout restart_timeout

[get_search_concurrency(2)]
description = get_search_concurrency
args = shcluster_label,title
definition = eval title="$title$" , $shcluster_label$=lower($shcluster_label$)\
| lookup splunk_rest_admin_search_concurrency_settings_handler_sh_kv_store_lookup shcluster_label AS $shcluster_label$ title OUTPUTNEW max_searches_perc auto_summary_perc base_max_searches max_rt_search_multiplier max_searches_per_cpu max_auto_summary_searches max_hist_scheduled_searches max_hist_searches max_rt_scheduled_searches max_rt_searches\
| fields - title


[get_lookup_reference(1)]
description = Extracts Any Reference to Lookups
args = field
definition = rex field=$field$ max_match=100 "\|\s*inputlookup\s+(?<Input_Lookup>[^|]+)" \
| rex field=$field$ max_match=100 "\|\s*from\s+inputlookup:(?<From_Input_Lookup>[^|]+)" \
| rex field=$field$ max_match=100 "\|\s*from\s+lookup:(?<From_Lookup>[^|]+)" \
| rex field=$field$ max_match=100 "\|\s*outputlookup\s+(?<Output_Lookup>[^|]+)" \
| rex field=$field$ max_match=100 "\|\s*lookup\s+(?<Lookup_Lookup>[^|\s]+)" \
| eval Input_Lookup = "Input_Lookup:".Input_Lookup , From_Input_Lookup = "From_Input_Lookup:".From_Input_Lookup, From_Lookup = "From_Lookup:".From_Lookup, Output_Lookup = "Output_Lookup:".Output_Lookup, Lookup_Lookup = "Lookup_Lookup:".Lookup_Lookup\
| eval Lookup_Reference=mvsort(mvdedup(lower(mvappend(Lookup_Lookup,Input_Lookup,From_Lookup,From_Input_Lookup,Output_Lookup)))) \
| rex field=Lookup_Reference mode=sed "s/\"|append=\w+|create_empty=\w+|createinapp=\w+|override_if_empty=\w+|event_time_field=\w+|output_format=\w+|local=\w+|update=\w+|key_field=\w+|enabled=\w+|max=\w+|type=\w+|\s+where\s+.*|\$//g" \
| rex field=Lookup_Reference mode=sed "s/(\s|\]).*$//g"\
| eval Lookup_Reference=if(((Lookup_Reference == "") OR isnull(Lookup_Reference)),"no-lookup-reference", mvsort(mvdedup(trim(Lookup_Reference)))) \
| fields - Input_Lookup,From_Input_Lookup,From_Lookup,Output_Lookup,Lookup_Lookup\
| fillnull value="no-lookup-reference" Lookup_Reference

[get_macro_reference(1)]
description = Extracts Any Reference to Macros
args = field
definition = rex field=$field$ max_match=0 "(?<Macro_Reference1>`.*`)" \
| makemv delim="|" Macro_Reference1 \
| rex field=Macro_Reference1 max_match=0 "^\`(?<Macro_Reference2>.*?)\`" \
| rex field=Macro_Reference2 mode=sed "s/\"|^\$.*//g" \
| eval Macro_Reference2 = mvfilter ( ( ! match(Macro_Reference2,"^comment|^gmc_comment") ) ) \
| eval Macro_Reference=if(((Macro_Reference2 == "") OR isnull(Macro_Reference2)),"no-macro-reference", mvdedup(mvsort(Macro_Reference2))) \
| fields - Macro_Reference1 Macro_Reference2\
| fillnull value="no-macro-reference" Macro_Reference

[get_datamodel_reference(1)]
description = Extracts Any Reference to Data Models
args = field
definition = rex field=$field$ max_match=100 "[fF][rR][oO][mM]\s*[dD][aA][tT][aA][mM][oO][dD][eE][lL][:=](?<Datamodel_Reference1>.*?)\s" \
| rex field=$field$ max_match=100 "\|\s*(datamodel|datamodelsimple)\s+(?<Datamodel_Reference2>.*?)\s" \
| eval Datamodel_Reference=coalesce(Datamodel_Reference1,Datamodel_Reference2) \
| rex field=Datamodel_Reference mode=sed "s/\"//g" \
| eval Datamodel_Reference = mvfilter( ! match(Datamodel_Reference, "^\$|type=|^\|") )\
| eval Datamodel_Reference=if(((Datamodel_Reference == "") OR isnull(Datamodel_Reference)),"no-datamodel-reference", mvdedup(mvsort(Datamodel_Reference)))\
| fields - Datamodel_Reference1 Datamodel_Reference2\
| fillnull value="no-datamodel-reference" Datamodel_Reference

[get_index_reference(1)]
description = Extracts Any Reference to Index(es)
args = field
definition = rex field=$field$ max_match=100 "index\\s*=\\s*(?<Index_Reference1>.*?)[\\s\"\\|]" \
| rex field=Index_Reference1 mode=sed "s/^[\\s$?><()\\\\,^=\\]\\[+]*//g" \
| rex field=$field$ max_match=100 "index\\s+IN\\s*\\((?<Index_Reference2>.*?)\\)" \
| makemv delim="," Index_Reference2 \
| rex field=Index_Reference2 mode=sed "s/^[\\s$?><()\\\\,^=]*//g" \
| eval Index_Reference=coalesce(Index_Reference1,Index_Reference2), Index_Reference=case(match(Index_Reference,"\\*"),"All non-internal indexes",match(Index_Reference,"_\\*"),"All internal indexes",true(),Index_Reference), Index_Reference=mvfilter((!match(Index_Reference,"^index|^trim|^\/|^ifindex|^mvjoin|eval index="))), Index_Reference=mvdedup(mvsort(Index_Reference)) \
| eval Index_Reference=if(((Index_Reference == "") OR isnull(Index_Reference)),"no-index-reference",Index_Reference)\
| rex field=Index_Reference mode=sed "s/\"|\(|\)|\[|\]//g" \
| fields - Index_Reference1 Index_Reference2\
| fillnull value="no-index-reference" Index_Reference
iseval = 0

[get_sourcetype_reference(1)]
description = Extracts Any Reference to Source Type(s)
args = field
definition = rex field=$field$ max_match=100 "sourcetype\\s*=\\s*(?<Sourcetype_Reference1>.*?)[\\s\"\\|]" \
| rex field=Sourcetype_Reference1 mode=sed "s/^[\\s$?><()\\\\,^=]*//g" \
| rex field=$field$ max_match=100 "sourcetype\\s+IN\\s*\\((?<Sourcetype_Reference2>.*?)\\)" \
| makemv delim="," Sourcetype_Reference2 \
| rex field=Sourcetype_Reference2 mode=sed "s/^[\\s$?><()\\\\,^=]*//g" \
| eval Sourcetype_Reference=coalesce(Sourcetype_Reference1,Sourcetype_Reference2), Sourcetype_Reference=mvfilter((! match(Sourcetype_Reference,"^sourcetype|^trim|ifisnull|^\"|\[|\]"))), Sourcetype_Reference=mvdedup(mvsort(Sourcetype_Reference)) \
| rex field=Sourcetype_Reference mode=sed "s/\(|\)//g"\
| eval Sourcetype_Reference=if(((Sourcetype_Reference == "") OR isnull(Sourcetype_Reference)),"no-sourcetype-reference",Sourcetype_Reference)\
| fields - Sourcetype_Reference1 Sourcetype_Reference2\
| fillnull value="no-sourcetype-reference" Sourcetype_Reference

[get_source_reference(1)]
description = Extracts Any Reference to Source(s)
args = field
definition = rex field=$field$ max_match=100 "source\\s*=\\s*(?<Source_Reference1>.*?)[\\s\"\\|]" \
| rex field=Source_Reference1 mode=sed "s/^[\\s$?><()\\\\,^=]*//g" \
| rex field=$field$ max_match=100 "source\\s+IN\\s*\\((?<Source_Reference2>.*?)\\)" \
| makemv delim="," Source_Reference2 \
| rex field=Source_Reference2 mode=sed "s/^[\\s$?><()\\\\,^=]*//g" \
| eval Source_Reference=coalesce(Source_Reference1,Source_Reference2), Source_Reference=mvfilter((! match(Source_Reference,"^source|^\"|^ifisnull"))), Source_Reference=mvdedup(mvsort(Source_Reference)) \
| eval Source_Reference=if(((Source_Reference == "") OR isnull(Source_Reference)),"no-source-reference",Source_Reference)\
| fields - Source_Reference1 Source_Reference2\
| fillnull value="no-source-reference" Source_Reference

[get_eventtype_reference(1)]
description = Extracts Any Reference to Event Type(s)
args = field
definition = rex field=$field$ max_match=100 "eventtype\\s*=\\s*(?<Eventtype_Reference1>.*?)[\\s\"\\|]" \
| rex field=Eventtype_Reference1 mode=sed "s/^[\\s$?><()\\\\,^=\\]\\[+]*//g" \
| rex field=$field$ max_match=100 "eventtype\\s+IN\\s*\\((?<Eventtype_Reference2>.*?)\\)" \
| makemv delim="," Eventtype_Reference2 \
| rex field=Eventtype_Reference2 mode=sed "s/^[\\s$?><()\\\\,^=]*//g" \
| eval Eventtype_Reference=coalesce(Eventtype_Reference1,Eventtype_Reference2), Eventtype_Reference=mvfilter((! match(Eventtype_Reference,"^eventtype|^trim|ifisnull|^\""))), Eventtype_Reference=mvdedup(mvsort(Eventtype_Reference))\
| eval Eventtype_Reference=if(((Eventtype_Reference == "") OR isnull(Eventtype_Reference)),"no-eventtype-reference",Eventtype_Reference)\
| fields - Eventtype_Reference1 Eventtype_Reference2\
| fillnull value="no-eventtype-reference" Eventtype_Reference

[get_report_reference(1)]
description = Extracts Any Reference to Report(s)
args = field
definition = rex field=$field$ max_match=100 "<search ref=\"(?<Report_Reference>\w+)\"></search>"\
| eval Report_Reference=if(((Report_Reference == "") OR isnull(Report_Reference)),"no-report-reference",Report_Reference)\
| fillnull value="no-report-reference" Report_Reference

[get_dashboard_reference(1)]
description = Extracts Any Reference to Dashboard(s)
args = field
definition = rex field=$field$ max_match=100 "href=\"(?<Dashboard_Reference>\w+)\">"\
| eval Dashboard_Reference=mvdedup(mvsort(Dashboard_Reference)), Dashboard_Reference=if(((Dashboard_Reference == "") OR isnull(Dashboard_Reference)),"no-dashboard-reference",mvdedup(mvsort(Dashboard_Reference)))\
| fillnull value="no-dashboard-reference" Dashboard_Reference

[get_rest_reference(1)]
description = Extracts Any Reference to REST Calls
args = field
definition = rex field=$field$ max_match=100 "\|\s*rest\s+(?<Rest_Reference>.*?)[|\]\n\r]"\
| eval Rest_Reference = mvfilter ( (! match(Rest_Reference,"^\$")))\
| rex field=Rest_Reference mode=sed "s/\"//g"\
| eval Rest_Reference = mvdedup(mvsort(Rest_Reference))\
| eval Rest_Reference=if(((Rest_Reference == "") OR isnull(Rest_Reference)),"no-rest-reference", mvdedup(mvsort(Rest_Reference)))\
| fillnull value="no-rest-reference" Rest_Reference

### Field Renames

[rename_instance_fields]
description = Renames Splunk Instance REST Fields to human-readable format
definition = rename \
    numberOfCores AS "Instance pCPU"\
    numberOfVirtualCores AS "Instance vCPU"\
    version AS "Instance Version"\
    os_name AS "Instance OS"\
    os_version AS "Instance OS Version" \
    startup_time AS "Instance OS Startup" \
    isForwarding AS "Instance Forwarding?" \
    ulimits_open_files AS "Instance Ulimits Open Files" \
    ulimits_stack_size AS "Instance Ulimits Stack Size" \
    ulimits_user_processes AS "Instance Ulimits User Processes" \
    transparent_hugepages_defrag AS "Instance THP Defrag Status" \
    transparent_hugepages_enabled AS "Instance THP Status" \
    transparent_hugepages_effective_state AS "Instance THP State" \
    host_ip AS "Instance IP" \
    host_fqdn AS "Instance FQDN" \
    host_short AS "Instance Hostname"\
    appServerPorts AS "Instance App Port" \
    dfsDisabled AS "Instance DFS Disabled?" \
    dfsMasterPort AS "Instance DFS Master Port" \
    enableSplunkWebSSL AS "Instance HTTPS Enabled?" \
    httpport AS "Instance  Web Port" \
    kvStoreDisabled AS "Instance KV Store Disabled?" \
    kvStorePort AS "Instance KV Store Port" \
    mgmtHostPort AS "Instance Management Port" \
    minFreeSpace AS "Instance  Pause Indexing Below" \
    sessionTimeout AS "Instance Session Timeout" \
    startwebserver AS "Instance Run Splunk Web?" \
    trustedIP AS "Instance Trusted IP"\
    physicalMemoryMB AS "Instance Memory (MB)"\
    physicalMemoryGB AS "Instance Memory (GB)"\
    guid AS GUID

[rename_reference_fields]
description = Renames Reference Fields to human-readable format
definition = rename \
    Datamodel_Reference AS "Datamodel Reference"\
    decompressed_slices AS "Decompressed Slices"\
    Eventtype_Reference AS "Eventtype Reference"\
    Index_Reference AS "Index Reference"\
    Lookup_Reference AS "Lookup Reference"\
    Macro_Reference AS "Macro_Reference"\
    Sourcetype_Reference AS "Sourcetype Reference"\
    Source_Reference AS "Source Reference"\
    Report_Reference AS "Report Reference"\
    Dashboard_Reference AS "Dashboard Reference"\
    Rest_Reference AS "Rest Reference"

[rename_itsi_fields]
description = Renames ITSI Fields to human-readable format
definition = rename \
    kpi_title AS "ITSI KPI(s)"\
    service_title AS "ITSI Service(s)"

[rename_saved_searches_fields]
description = Renames Saved Searches REST Fields to human-readable format
definition = rename\
    author AS "Job Owner"\
    app AS "Job App"\
    sharing AS "Job App Sharing"\
    allow_skew AS "Job Allow Skew"\
    auto_summarize AS "Job Report Accelerated?"\
    cron_schedule AS "Job Schedule"\
    description AS "Job Description"\
    dispatch_earliest_time AS "Job Dispatch ET"\
    dispatch_latest_time AS "Job Dispatch LT"\
    max_concurrent AS "Job Max Concurrent"\
    realtime_schedule AS "Job RT Schedule"\
    savedsearch_type AS "Job Type"\
    schedule_priority AS "Job Schedule Priority"\
    schedule_window AS "Job Schedule Window"\
    is_scheduled AS "Job Scheduled?"\
    run_n_times AS "Job Run N Times"\
    run_on_startup AS "Job Run on Startup?"\
    savedsearch_name AS "Job Name"\
    disabled AS "Job Disabled?"\
    is_visible AS "Job Visible?"\
    acl_perms_read As "Read Permissions"\
    acl_perms_write As "Write Permissions"\
    email_to AS "Job Email Recipients"\
    savedsearch_search AS "Job Search" \
    email AS "Job Send Email?" \
    logevent AS "Job Logevent?" \
    logevent_param_event AS "Job Event Message"\
    lookup AS "Job Output to Lookup?" \
    lookup_append AS "Job Append Lookup?" \
    lookup_filename AS "Job Lookup File"\
    output_message AS "Job Messages?" \
    output_message_param_msgid AS "Job Message ID" \
    output_message_param_name AS "Job Message Name" \
    populate_lookup AS "Job Populate Lookup?" \
    script AS "Job Run Script?" \
    script_filename AS "Job Script Name" \
    webhook AS "Job Run Webhook?" \
    webhook_param_url AS "Job Webhook URL" \
    summary_index AS "Job Summary Indexing?" \
    summary_index_name AS "Job Summary Index Name" \
    auto_summarize_cron_schedule AS "Job Summary Indexing Schedule" \
    auto_summarize_dispatch_earliest_time AS "Job Summary Indexing ET" \
    auto_summarize_dispatch_latest_time AS "Job Summary Indexing LT" \
    auto_summarize_max_concurrent AS "Job Summary Indexing Max Concurrent" \
    dispatch_ttl AS "Job TTL"\
    qualifiedSearch AS "Job Qualified Search" \
    correlationsearch_enabled AS "Job Correlation Search?" \
    correlationsearch_label AS "Job Correlation Search Name"\
    correlationsearch_related_searches AS "Job Correlation Search Related Searches"\
    cron_schedule_described AS "Job Schedule Human"\
    scheduled_times AS "Job Sample Scheduled Times"\
    updated AS "Job Update Time"\
    Days_Latest_Access_Display AS "Job Last Access"\
    next_scheduled_time AS "Job Next Scheduled Times"\
    populate_lookup_dest As "Job Lookup"\
    actions As "Job Trigger Actions"\
    dispatch_as As "Job Run As"

#[rename_saved_searches_usage_fields]
#description = Renames Saved Searches Usage Fields to human-readable format
#definition = rename\
#    Scheduled_Time AS "Job Usage Scheduled Time"\
#Savedsearch_Name, App, User, Scheduled_Time, Priority, Dispatch_Time, Window_Time, Earliest_Access, Latest_Access, Run_Time, Result_Count    
#iseval = 0

[rename_macros_fields]
description = Renames Macros REST Fields to human-readable format
definition = rename\
    author AS "Macro Owner"\
    app AS "Macro App"\
    sharing AS "Macro App Sharing"\
    description AS "Macro Description"\
    disabled AS "Macro Disabled?"\
    updated AS "Macro Update Time"\
    title AS "Macro Name"\
    definition AS "Macro Definition"\
    args AS "Macro Arguments"\
    errormsg AS "Macro Error Msg"\
    iseval AS "Macro Using eval-based definition?"\
    validation AS "Macro Validation"

[rename_hec_fields]
description = Renames HTTP Event Collector REST Fields to human-readable format
definition = rename\
    app AS "HEC App"\
    disabled AS "HEC Token Disabled?"\
    title AS "HEC Name"\
    token_name AS "HEC Token Name"\
    token AS "HEC Token ID"\
    index AS "HEC Index"\
    indexes AS "HEC Indexes"\
    source AS "HEC Source"\
    sourcetype AS "HEC Sourcetype"\
    useACK AS "HEC useACK?"      

[rename_dashboards_fields]
description = Renames Dashboards REST Fields to human-readable format
definition = rename \
    title AS "Dashboard Name on Disk" \
    app AS "Dashboard App"\
    sharing AS "Dashboard App Sharing"\
    type AS "Dashboard Type"\
    author AS "Dashboard Owner"\
    updated AS "Dashboard Update Time"\
    label AS "Dashboard Name" \
    description AS "Dashboard Sescription" \
    search AS "Dashboard Searches" \
    BaseSearch AS "Dashboard Base Searches"\
    location AS "Dashboard Location"\
    description AS "Dashboard Description"\
    dashboard_size AS "Dashboard Size"\
    acl_perms_read As "Read Permissions"\
    acl_perms_write As "Write Permissions"\
    Days_Latest_Access_Display AS "Dashboard Last Access"

[rename_lookup_fields]
description = rename_lookup_fields
definition = rename \
    updated AS "Lookup Update Time"\
    app AS "Lookup App"\
    sharing AS "Lookup App Sharing"\
    description AS "Lookup Description"\
    author AS "Lookup Owner"\
    disabled AS "Lookup Disabled?"\
    Type AS "Lookup Type"\
    Lookup AS "Lookup Name"\
    Filename AS "Lookup Filename"\
    Lookup_File_Path AS "Lookup File Path"\
    Collection AS "Lookup Collection Name"\
    Match_Type AS "Lookup Match Type"\
    Replicate AS "Lookup Replication?"\
    Allow_Caching AS "Lookup Allow Caching?"\
    Filter AS "Lookup Filter"\
    Index_Fields_List AS "Lookup Index Fields List"\
    Min_Matches AS "Lookup Min Matches"\
    Max_Matches AS "Lookup Max Matches"\
    Fields_List AS "Supported Fields (Lookup Definitions)"\
    case_sensitive_match AS "Lookup Case Sensitive Match?"

[rename_auto_lookup_fields]
description = rename_auto_lookup_fields
definition = rename \
    author AS "Auto Lookup Owner"\
    updated AS "Auto Lookup Update Time"\
    app AS "Auto Lookup App"\
    sharing AS "Auto Lookup App Sharing"\
    description AS "Auto Lookup Description"\
    attribute AS "Auto Lookup Name"\
    transform AS "Lookup Definition"\
    value AS "Auto Lookup Input/Output Fields"\
    overwrite AS "Auto Lookup Overwrite Field Values"\
    stanza AS "Auto Lookup Source Type"

[rename_identity_fields]
description = Renames Identity Fields to human-readable format
definition = rename \
    identity AS Identity\
    emp_cc AS "User Cost Center"\
    email AS "User Email"\
    emp_ttl AS "User Job Title"\
    emp_dep AS "User Department"\
    emp_status AS "User Employment Status"\
    emp_type AS "User Employment Type"\
    emp_floor AS "User Floor Number"\
    emp_name AS "User Full Name"\
    emp_lob AS "User LOB"\
    emp_loc AS "User Location Code"\
    work_city AS "User City" \
    work_country AS "User Country" \
    work_region AS "User Region/State"\
    managedBy AS "User Manager"\
    bunit AS "User Business Unit"\
    startDate AS "User Hire Date"\
    endDate AS "User Termination Date"\
    first AS "User First Name"\
    last AS "User Last Name"\
    phone AS "User Phone"\
    splunk_role_map AS "User Splunk Roles"\
    ldap_group_name AS "User LDAP Group Name"\
    ldap_group_type AS "User LDAP Group Type"\
    last_successful_login AS "User Last Successful Login (REST)"\
    locked-out AS "User Locked Out?"\
    emp_tz AS "User Time Zone"\
    nick AS "User Nick Name"\
    phone2 AS "User Phone2"\
    prefix AS "User Prefix"\
    priority AS "User Priority"\
    suffix AS "User Suffix"\
    work_lat AS "User Work Lat"\
    work_long AS "User Work Lon"\
    category AS "User Category"\
    watchlist AS "User  Watch List?"
#    type AS "User Splunk Authentication Type"

[rename_license_fields]
description = Renames License Fields to human-readable format
definition = rename \
    idxcluster_label AS "Indexer Cluster"\
    Lic_Pool AS "License Pool"\
    Index_Name AS "Index Name"\
    Lic_Sourcetype AS "Source Type"\
    Lic_Source AS "Source"\
    Lic_Host AS "Host"\
    Lic_Pool_Size AS "Pool Size (Bytes)"\
    Lic_Pool_Size_MB AS "Pool Size (MB)"\
    Lic_Pool_Size_GB AS "Pool Size (GB)"\
    Lic_Pool_Size_TB AS "Pool Size (TB)"\
    License_Usage AS "License Usage (Bytes)"\
    License_Usage_MB AS "License Usage (MB)"\
    License_Usage_GB AS "License Usage (GB)"\
    License_Usage_TB AS "License Usage (TB)"

[rename_shcluster_fields]
description = Renames SH Cluster REST Fields to human-readable format
definition = rename mode AS "mode"\
    conf_deploy_fetch_url AS "conf_deploy_fetch_url"\
    adhoc_searchhead AS "Ad-Hoc SH"\
    replication_factor AS "replication_factor"\
    replication_port AS "replication_port"\
    replication_use_ssl AS "replication_use_ssl"\
    async_replicate_on_proxy AS "async_replicate_on_proxy"\
    register_replication_address AS "register_replication_address"\
    captain_is_adhoc_searchhead AS "Captain NO Saved Searches"\
    decommission_search_jobs_wait_secs AS "decommission_search_jobs_wait_secs"\
    dynamic_captain AS "dynamic_captain"\
    heartbeat_period AS "heartbeat_period"\
    manual_detention AS "manual_detention"\
    max_peer_rep_load AS "max_peer_rep_load"\
    percent_peers_to_restart AS "percent_peers_to_restart"\
    ping_flag AS "ping_flag"\
    preferred_captain AS "preferred_captain"\
    quiet_period AS "quiet_period"\
    rolling_restart AS "rolling_restart"\
    cxn_timeout AS "cxn_timeout"\
    heartbeat_timeout AS "heartbeat_timeout"\
    rcv_timeout AS "rcv_timeout"\
    send_timeout AS "send_timeout"\
    rep_cxn_timeout AS "rep_cxn_timeout"\
    rep_max_rcv_timeout AS "rep_max_rcv_timeout"\
    rep_max_send_timeout AS "rep_max_send_timeout"\
    rep_rcv_timeout AS "rep_rcv_timeout"\
    rep_send_timeout AS "rep_send_timeout"\
    restart_timeout AS "restart_timeout"

[get_field_desc(1)]
description = Retrieves GMC Data Model Field Description
args = Field_Name
definition = lookup splunk_fields_all_csv_lookup Field_Name AS $Field_Name$ OUTPUTNEW Field_Description

[gmc_time_format(1)]
description = Time Formatter
args = time
definition = $time$ = strftime($time$, "%m/%d/%Y %H:%M:%S")

[gmc_drop_dm_object_name(1)]
description = gmc_drop_dm_object_name
args = object
definition = rename "$object$.*" as *

[from_introspection]
description = from_introspection
definition = from datamodel:GMC.Introspection_Search_Usage \
| `get_instance_info(host)` \
| fields _time Splunk_Roles host search_id search_head app user acceleration_id delta_scan_count total_run_time fd_used mem_used normalized_pct_cpu page_faults pct_cpu pct_memory pid ppid provenance read_mb savedsearch_name scan_count search_type status t_count written_mb mode

[from_audit]
description = from_audit
definition = from datamodel:GMC.Audit_Search \
| `get_instance_info(host)` \
| fields _time Splunk_Roles host available_count considered_events datamodel decompressed_slices event_count dispatch_time exec_time info result_count roles savedsearch_name scan_count search search_et search_id search_lt search_startup_time search_type searched_buckets total_run_time total_slices user

[from_internal]
description = from_internal
definition = from datamodel:GMC.Internal_Scheduler \
| `get_instance_info(host)` \
| fields _time Splunk_Roles host app search_id_normalized concurrency_category concurrency_context concurrency_limit dispatch_time priority reason result_count total_run_time savedsearch_id savedsearch_name scheduled_time search_id search_type skipped_count info user window_time alert_actions Total_Executions Skipped_Executions

[skip_ratio(1)]
description = skip_ratio
args = Splunk_Roles
definition = tstats SUMMARIESONLY=TRUE ALLOW_OLD_SUMMARIES=TRUE \
    sum(Search_Activity.Internal_Scheduler.is_Internal_Total_Executions) as Total_Executions\
    sum(Search_Activity.Internal_Scheduler.is_Internal_Skipped_Executions) as Skipped_Executions\
    FROM DATAMODEL=GMC\
    WHERE nodename=Search_Activity.Internal_Scheduler\
    index=_internal\
    AND Search_Activity.Internal_Scheduler.savedsearch_name2 = "*"\
    AND Search_Activity.Internal_Scheduler.app2 = "*"\
    AND Search_Activity.Internal_Scheduler.search_type2 = "*" \
    AND Search_Activity.Internal_Scheduler.info2 = "*"\
    AND Search_Activity.Internal_Scheduler.user2 = "*"\
    AND host = "*"\
    Search_Activity.Internal_Scheduler.info2 IN ( "completed" , "skipped")\
    BY host \
| `drop_dm_object_name(Search_Activity.Internal_Scheduler)` \
| rename info2 AS info , host AS Instance \
| `get_instance_roles(Instance)` \
| eval Skip_Ratio = ( (Skipped_Executions / Total_Executions) * 100), Skip_Ratio = ( round(Skip_Ratio, 2) . "%") \
| table Splunk_Roles Instance Total_Executions Skipped_Executions Skip_Ratio \
| search Splunk_Roles = "$Splunk_Roles$"

[gmc_identities]
description = identities
definition = inputlookup splunk_identities_kv_store_lookup \
| table identity,prefix,nick,first,last,suffix,email,phone,phone2,managedBy,priority,bunit,category,watchlist,startDate,endDate,work_city,work_country,work_lat,work_long,work_region,emp_cc,emp_dep,emp_floor,emp_lob,emp_loc,emp_name,emp_status,emp_ttl,emp_type,emp_tz,Splunk_Instance\
| `rename_identity_fields`

[custom_identities]
description = identities
definition = inputlookup splunk_identities_custom_sh_csv_lookup \
| table identity,prefix,nick,first,last,suffix,email,phone,phone2,managedBy,priority,bunit,category,watchlist,startDate,endDate,work_city,work_country,work_lat,work_long,work_region,emp_cc,emp_dep,emp_floor,emp_lob,emp_loc,emp_name,emp_status,emp_ttl,emp_type,emp_tz\
| `rename_identity_fields`

[get_fields_list]
description = get_fields_list
definition = rename "eai:acl.*" as "*" , "eai:*" AS "*"\
| fields - "perms.*", "can_*", id, published, removable, modifiable, updated \
| fieldsummary \
| rename field AS Fields_List \
| fields Fields_List \
| where Fields_List!="Fields_List" \
| mvcombine Fields_List \
| eval Fields_List=mvjoin(Fields_List," ")

[rename_search_concurrency_fields]
description = Renames SH Search Concurrency REST Fields to human-readable format
definition = rename \
    base_max_searches AS "Base Max Searches" \
    max_auto_summary_searches AS "Max Auto Summary Searches" \
    max_hist_scheduled_searches AS "Max Historical Scheduled Searches"\
    max_hist_searches AS "Max Historical Searches" \
    max_searches_per_cpu AS "Max Searches Per CPU"\
    max_searches_perc AS "Max Searches %" \
    auto_summary_perc AS "Auto Summary %" \
    max_rt_search_multiplier AS "Max Real-Time Search Multiplier" \
    max_rt_scheduled_searches AS "Max Real-Time Scheduled Searches" \
    max_rt_searches AS "Max Real-Time Searches"

[strptime_format(1)]
description = strptime_format
args = time
definition = rex field=$time$ mode=sed "s/^19.*//g"\
| eval $time$ = strptime($time$, "%Y-%m-%dT%H:%M:%S%z")

[strftime_format(1)]
description = strftime_format
args = time
#definition = eval $time$ = strftime($time$, "%m/%d/%Y %H:%M:%S")
definition = eval $time$ = strftime($time$, "%A %B %d, %Y %I:%M:%S %p %Z")

[ustime_format(1)]
description = ustime_format
args = time
definition = eval $time$ = strftime($time$, "%a %b %d %Y %H:%M:%S (%Z)")

[fix_identities_info]
description = fix_identities_info
definition = eval \
    work_city = case ( match(work_city, "Ciudad Autonoma Buenos Aires"), "Buenos Aires", \
    match(work_city, "Frankfurt Am Main"), "Frankfurt",\
    true(), work_city ) , \
    work_region = case ( match(work_region, "mic"), "MI",\
    true(), work_region ) , \
    work_country = case( match(work_country, "(?i)usa"), "United States", \
    work_country="IND", "India", work_country="ARG", "Argentina",\
    true(), work_country ),\
    emp_loc = case ( isnull(emp_loc), "SFO",\
    true(), emp_loc ), \
    emp_type = case ( isnull(emp_type), "Employee",\
    true(), emp_type ), \
    emp_status = case ( isnull(emp_status), "Active",\
    true(), emp_status )

[set_geo_defaults]
description = set_geo_defaults
definition = eval \
    work_city = if(isnull(work_city), "San Francisco", work_city),\
    work_region=if(isnull(work_region) AND work_country="United States", "CA", work_region),\
    work_country = if(isnull(work_country), "United States", work_country)

[get_geo_info(3)]
description = get_geo_info
args = work_city,work_region,work_country
definition = lookup splunk_cities_geo_sh_csv_lookup city AS $work_city$ region AS $work_region$ country AS $work_country$ OUTPUTNEW latitude AS work_lat longitude AS work_long\
| lookup splunk_cities_geo_sh_csv_lookup city AS $work_city$ region_code AS $work_region$ country AS $work_country$ OUTPUTNEW latitude AS work_lat longitude AS work_long\
| lookup splunk_cities_geo_sh_csv_lookup city AS $work_city$ country AS $work_country$ OUTPUTNEW latitude AS work_lat longitude AS work_long\
| lookup splunk_cities_geo_sh_csv_lookup city AS $work_city$ OUTPUTNEW latitude AS work_lat longitude AS work_long

[get_iplocation_info(1)]
description = get_iplocation_info
args = ip
definition = fillnull value="unknown" $ip$\
| mvexpand $ip$\
| iplocation $ip$ allfields=false\
| eval\
    work_city = if(isnotnull(City) AND City!="", City, work_city),\
    work_region = if(isnotnull(Region) AND Region!="", Region, work_region),\
    work_country = if(isnotnull(Country) AND Country!="", Country, work_country),\
    work_lat = if(isnotnull(lat) AND lat!="", lat, work_lat),\
    work_long = if(isnotnull(lon) AND lon!="", lon, work_long)\
|  mvcombine $ip$

[get_iplocation_info2(1)]
description = get_iplocation_info
args = ip
definition = fillnull value="unknown" $ip$\
    | foreach $ip$\
    [ mvexpand <<FIELD>>\
    | iplocation <<FIELD>>]\
| eval\
    work_city = if(isnotnull(City) AND City!="", City, work_city),\
    work_region = if(isnotnull(Region) AND Region!="", Region, work_region),\
    work_country = if(isnotnull(Country) AND Country!="", Country, work_country),\
    work_lat = if(isnotnull(lat) AND lat!="", lat, work_lat),\
    work_long = if(isnotnull(lon) AND lon!="", lon, work_long)

[tstats_gmc_introspection]
description = tstats_gmc_introspection
definition = latest(Search_Activity.Introspection_Search_Usage.acceleration_id) AS acceleration_id\
    latest(Search_Activity.Introspection_Search_Usage.app3) AS app\
    max(Search_Activity.Introspection_Search_Usage.delta_scan_count) AS delta_scan_count\
    max(Search_Activity.Introspection_Search_Usage.total_run_time3) AS total_run_time\
    max(Search_Activity.Introspection_Search_Usage.fd_used) AS fd_used\
    max(Search_Activity.Introspection_Search_Usage.mem_used) AS mem_used\
    max(Search_Activity.Introspection_Search_Usage.normalized_pct_cpu) AS normalized_pct_cpu\
    max(Search_Activity.Introspection_Search_Usage.pct_cpu) AS pct_cpu\
    max(Search_Activity.Introspection_Search_Usage.page_faults) AS page_faults\
    latest(Search_Activity.Introspection_Search_Usage.provenance) AS provenance\
    max(Search_Activity.Introspection_Search_Usage.read_mb) AS read_mb\
    latest(Search_Activity.Introspection_Search_Usage.savedsearch_name3) AS savedsearch_name\
    max(Search_Activity.Introspection_Search_Usage.scan_count3) AS scan_count\
    latest(Search_Activity.Introspection_Search_Usage.search_type3) AS search_type\
    max(Search_Activity.Introspection_Search_Usage.t_count) AS t_count\
    latest(Search_Activity.Introspection_Search_Usage.user3) AS user\
    max(Search_Activity.Introspection_Search_Usage.written_mb) AS written_mb\
    latest(Search_Activity.Introspection_Search_Usage.search_head) as search_head\
    latest(Search_Activity.Introspection_Search_Usage.mode) as mode\
    latest(Search_Activity.Introspection_Search_Usage.ppid) as ppid\
    values(host) as host

[rename_gmc_introspection_fields]
description = Renames GMC Introspection Data Model Fields to human-readable format
definition = eval mode = case (\
    mode = "RT", "Real-Time", \
    mode = "RT indexed", "Real-Time Indexed", \
    mode = "historical", "Historical", \
    mode = "historical batch", "Historical Batch",\
    true(), mode)\
| eval Provenance_Type = case (\
    Provenance_Type = "UI", "User Interface", \
    Provenance_Type = "scheduler", "Scheduler", \
    Provenance_Type = "summary_director", "Report Summarization", \
    Provenance_Type = "rest", "Rest",\
    Provenance_Type = "Splunkjs", "splunkjs",\
    Provenance_Type = "unknown", null(),\
    true(), Provenance_Type)\
| eval `gmc_time_format(_time)`\
| rename _time AS "Search Time"\
acceleration_id AS "Acceleration ID"\
Dashboard_Name AS "Dashboard"\
datamodel AS "Datamodel"\
delta_scan_count AS "Delta Scan Count"\
fd_used AS "Open Files"\
max_spent AS "Dashboard Load Time"\
mem_used AS "Memory Used"\
mode AS "Search Mode"\
normalized_pct_cpu AS "Normalized CPU %"\
pct_cpu AS "CPU %"\
page_faults AS "Page Faults"\
pid AS "PID"\
ppid AS "PPID"\
provenance AS "Provenance"\
Provenance_KO AS "Dashboard"\
Provenance_KO_Type AS "Provenance Type"\
Provenance_Type AS "Provenance"\
read_mb AS "Read MB"\
scan_count AS "Scan Count"\
search_head AS "Search Head"\
t_count AS "Thread Count"\
total_run_time AS "Runtime in Sec"\
'total_run_time' AS "Runtime"\
ulimits_open_files AS "Ulimit Open Files"\
ulimits_stack_size AS "Ulimit Stack Size"\
ulimits_user_processes AS "Ulimit User Processes"\
version AS "Splunk Version"\
written_mb AS "Written MB"\
search_id_normalized AS search_id_normalized\
app AS "App"\
search_type AS "Search Type"\
info AS "Status"\
user AS User\
host As "Splunk Instance"

[tstats_gmc_internal]
description = tstats_gmc_internal
definition = latest(Search_Activity.Internal_Scheduler.app2) AS app\
    latest(Search_Activity.Internal_Scheduler.concurrency_category) AS concurrency_category\
    latest(Search_Activity.Internal_Scheduler.concurrency_context) AS concurrency_context\
    latest(Search_Activity.Internal_Scheduler.concurrency_limit) AS concurrency_limit\
    latest(Search_Activity.Internal_Scheduler.dispatch_time2) AS dispatch_time\
    latest(Search_Activity.Internal_Scheduler.priority) AS priority\
    latest(Search_Activity.Internal_Scheduler.reason) AS reason\
    latest(Search_Activity.Internal_Scheduler.result_count2) AS result_count\
    latest(Search_Activity.Internal_Scheduler.total_run_time2) AS total_run_time\
    latest(Search_Activity.Internal_Scheduler.savedsearch_id) AS savedsearch_id\
    latest(Search_Activity.Internal_Scheduler.savedsearch_name2) AS savedsearch_name\
    latest(Search_Activity.Internal_Scheduler.scheduled_time) AS scheduled_time\
    latest(Search_Activity.Internal_Scheduler.search_type2) AS search_type\
    latest(Search_Activity.Internal_Scheduler.skipped_count) AS skipped_count\
    latest(Search_Activity.Internal_Scheduler.info2) AS info\
    latest(Search_Activity.Internal_Scheduler.user2) AS user\
    latest(Search_Activity.Internal_Scheduler.window_time) AS window_time\
    latest(Search_Activity.Internal_Scheduler.alert_actions) AS alert_actions\
    latest(Search_Activity.Internal_Scheduler.event_message) AS event_message\
    values(host) as host

[rename_gmc_internal_fields]
description = Renames GMC Internal Data Model Fields to human-readable format
definition = eval `gmc_time_format(scheduled_time)` , `gmc_time_format(dispatch_time)` , `gmc_time_format(_time)`\
| rename _time AS "Search Time"\
alert_actions AS "Alert Actions"\
concurrency_category AS "Concurrency Category"\
concurrency_context AS "Concurrency Context"\
concurrency_limit AS "Concurrency Limit"\
datamodel AS "Datamodel"\
priority AS "Schedule Priority"\
reason AS "Reason"\
result_count AS "Result Count"\
scheduled_time AS "Scheduled Time"\
skipped_count AS "Skipped Count"\
total_run_time AS "Runtime in Sec"\
'total_run_time' AS "Runtime"\
Memory_Threshold AS "Memory Threshold"\
Memory_Usage AS "Memory Usage"\
dispatch_time AS "Dispatch Time"\
search_id_normalized AS search_id_normalized\
app AS "App"\
search_type AS "Search Type"\
info AS "Status"\
host As "Splunk Instance"\
user AS User

[tstats_gmc_audit]
description = tstats_gmc_audit
definition = latest(Search_Activity.Audit_Search.available_count) AS available_count\
    latest(Search_Activity.Audit_Search.considered_events) AS considered_events\
    latest(Search_Activity.Audit_Search.datamodel1) AS datamodel\
    latest(Search_Activity.Audit_Search.decompressed_slices) AS decompressed_slices\
    latest(Search_Activity.Audit_Search.event_count) AS event_count\
    latest(Search_Activity.Audit_Search.dispatch_time1) AS dispatch_time\
    latest(Search_Activity.Audit_Search.exec_time) AS exec_time\
    latest(Search_Activity.Audit_Search.result_count1) AS result_count\
    latest(Search_Activity.Audit_Search.roles) AS roles\
    latest(Search_Activity.Audit_Search.savedsearch_name1) AS savedsearch_name\
    latest(Search_Activity.Audit_Search.scan_count1) AS scan_count\
    latest(Search_Activity.Audit_Search.search) AS search\
    latest(Search_Activity.Audit_Search.search_et) AS search_et\
    latest(Search_Activity.Audit_Search.search_lt) AS search_lt\
    latest(Search_Activity.Audit_Search.search_startup_time) AS search_startup_time\
    latest(Search_Activity.Audit_Search.search_type1) AS search_type\
    latest(Search_Activity.Audit_Search.searched_buckets) AS searched_buckets\
    latest(Search_Activity.Audit_Search.total_run_time1) AS total_run_time\
    latest(Search_Activity.Audit_Search.total_slices) AS total_slices\
    latest(Search_Activity.Audit_Search.user1) AS user\
    values(host) as host

[rename_gmc_audit_fields]
description = Renames GMC Audit Data Model Fields to human-readable format
definition = eval Time_Diff = search_lt - search_et | `gmc_convert_runtime(Time_Diff)`\
| `strftime_format(search_lt)`\
| `strftime_format(search_et)`\
| `strftime_format(dispatch_time)`\
| `strftime_format(_time)`\
| `strftime_format(exec_time)`\
| rename _time AS "Completion Time (_time)"\
'total_run_time' AS "Runtime"\
available_count AS "Available Count"\
considered_events AS "Considered Events"\
datamodel AS "Datamodel"\
decompressed_slices AS "Decompressed Slices"\
event_count AS "Event Count"\
result_count AS "Result Count"\
scan_count AS "Scan Count"\
search_et AS "Search ET"\
search_lt AS "Search LT"\
searched_buckets AS "Searched Buckets"\
Time_Diff AS "Time Difference"\
total_run_time AS "Runtime in Sec"\
total_slices AS "Total Slices"\
dispatch_time AS "Dispatch Time"\
search_id_normalized AS search_id_normalized\
app AS "App"\
search_type AS "Search Type"\
info AS "Status"\
host As "Splunk Instance"\
user AS User

[get_normalized_search_id(1)]
description = Normalize Search ID for the Splunk - SH - 04 - Audit Search Activity - Dashboard
args = search_id
definition = rex field=$search_id$ "_(?<search_id_normalized1>\d+[._]\d+)_" \
| rex field=$search_id$ "(?<search_id_normalized2>\d+[._]\d+$)" \
| rex field=$search_id$ "(?<search_id_normalized3>^\d+[._]\d+)" \
| eval search_id_normalized=if(isnull(search_id_normalized1),search_id_normalized2,search_id_normalized1) \
| eval search_id_normalized=if(isnull(search_id_normalized),search_id_normalized3,search_id_normalized) \
| eval search_id_normalized=if(isnull(search_id_normalized),search_id,search_id_normalized)\
| rex field=search_id_normalized mode=sed "s/\./_/g"\
`gmc_comment("| rex field=search_id_normalized mode=sed "s/^\w+;\w+;//g"")`\
| rex field=search_id_normalized mode=sed "s/^\w+;.*;|^_ACCELERATE_DM_|^_ACCELERATE_|_ACCELERATE_$//g"\
| fields - search_id_normalized1,search_id_normalized2,search_id_normalized3

[gmc_dm_constraints]
description = Limit what the GMC Data Model Accelerated Against
definition = search_group=dmc_group_search_head

[es_search_head]
description = Sets the ES Search Head Instance
definition = ES

[get_memory_tracker_fields]
description = Exracts Memory Tracker Fields
definition = rex field=event_message "physical\smemory\susage\s\((?<Memory_Usage>.*?)(percent|MB)"\
| rex field=event_message "exceeded\sthe\s'(?<Memory_Threshold>.*?)\'"

[get_datamodel_fields(1)]
description = Exracts Datamodel from Savedsearch Name field
args = field
definition = rex field=$field$ "_ACCELERATE_DM_(?<app>.*?)_" \
| eval $field$ = case(match($field$, "_ACCELERATE_|^search\d+"), null(), true(), $field$) \
| rex field=savedsearch_id "(?<DM_User>^.*?);(?<DM_App>.*?);_ACCELERATE_DM_(?<datamodel>.*)_ACCELERATE_$"

[gmc_comment(1)]
description = Comments out sections in search
args = text
definition = ""
iseval = 1

[get_cron_schedule(1)]
description = Converts Cron Schedule to human-readable format
args = cron_schedule
definition = lookup cron_schedule_map_csv_lookup $cron_schedule$ OUTPUTNEW cron_schedule_described\
| eval cron_schedule_described = if(isnull(cron_schedule_described) AND isnotnull(cron_schedule), "no-desc-found", cron_schedule_described)

[get_idxcluster_label_guid(1)]
description = Retrieves Splunk Indexer Info including the cluster label from its GUID
args = guid
definition = lookup splunk_rest_cluster_config_idx_kv_store_lookup guid AS $guid$ OUTPUTNEW Splunk_Instance AS Indexer_Name idxcluster_label

[normalize_search_type(1)]
description = Normalize GMC Search Types for Splunk - SH - 04 - Audit Search Activity - Dashboard
args = search_type
definition = eval $search_type$ = case (\
    $search_type$ = "adhoc", "Ad-Hoc", \
    $search_type$ = "datamodel_acceleration", "Datamodel Acceleration", \
    $search_type$ = "report_acceleration", "Report Acceleration", \
    $search_type$ = "scheduled", "Scheduled Jobs", \
    $search_type$ = "summary_indexing", "Summary Indexing", \
    $search_type$ = "realtime", "Real-Time", \
    $search_type$ = "subsearch", "Subsearch", \
    $search_type$ = "typeahead", "Typeahead", \
    true(), $search_type$)

[rename_common_fields]
description = Renames GMC Data Model Common Fields to human-readable format
definition = rename\
Splunk_Instance AS "Splunk Instance"\
Splunk_Roles AS "Splunk Roles"\
shcluster_label AS "SH Cluster Label"\
idxcluster_label AS "IDX Cluster Label"

[get_instance_roles(1)]
description = get_instance_roles
args = Splunk_Instance
definition = eval $Splunk_Instance$=lower($Splunk_Instance$)\
| lookup splunk_assets_kv_store_lookup Splunk_Instance AS $Splunk_Instance$ OUTPUTNEW Splunk_Roles\
| eval  Splunk_Roles = If(IsNull(Splunk_Roles) OR Splunk_Roles="", "No-Splunk_Roles", Splunk_Roles)\
| eval  Splunk_Instance = If(IsNull(Splunk_Instance) OR Splunk_Instance="", "No-Splunk_Instance", Splunk_Instance)

[rename_rest_fields]
description = Renames Common REST Fields to human-readable format
definition = rename \
    app AS "App"\
    sharing AS "App Sharing" \
    author AS Owner\
    updated AS "Update Time"\
    stanza AS "Stanza"\
    description AS Description\
    disabled AS Disabled

[get_shcluster_label(1)]
description = Retrieves Search Head Cluster Label
args = Splunk_Instance
definition = eval $Splunk_Instance$=lower($Splunk_Instance$)\
| lookup splunk_rest_shcluster_config_shc_kv_store_lookup Splunk_Instance AS $Splunk_Instance$ OUTPUTNEW shcluster_label\
| eval  shcluster_label = If(IsNull(shcluster_label) OR Splunk_Instance="No-Splunk_Instance", "No-shcluster_label", shcluster_label)

[get_idxcluster_label(1)]
description = Retrieves Indexer Cluster Label
args = Splunk_Instance
definition = eval $Splunk_Instance$=lower($Splunk_Instance$)\
| lookup splunk_rest_cluster_config_idx_kv_store_lookup Splunk_Instance AS $Splunk_Instance$ OUTPUTNEW idxcluster_label\
| eval  idxcluster_label = If(IsNull(idxcluster_label) OR Splunk_Instance="No-Splunk_Instance", "No-idxluster_label", idxcluster_label)

[get_dmc_assets_info(1)]
description = Retrieves All Custom Search Groups from the Monitoring Console dmc_assets Lookup Table
args = Splunk_Instance
definition = eval $Splunk_Instance$=upper($Splunk_Instance$)\
| lookup dmc_assets host AS $Splunk_Instance$ OUTPUTNEW search_group\
| eval $Splunk_Instance$=lower($Splunk_Instance$)

[gmc_byte2mb(1)]
description = Converts Bytes to MB
args = field
definition = eval $field$_MB=round($field$/1024/1024,3)

[gmc_byte2gb(1)]
description = Converts Bytes to GB
args = field
definition = eval $field$_GB=round($field$/1024/1024/1024,3)

[gmc_byte2tb(1)]
description = Converts Bytes to TB
args = field
definition = eval $field$_TB=round($field$/1024/1024/1024/1024,3)

[gmc_mb2gb(1)]
description = Converts MB to GB
args = field
definition = eval $field$_GB=round($field$/1024,3)

[gmc_mb2tb(1)]
description = Converts MB to TB
args = field
definition = eval $field$_TB=round($field$/1024/1024,3)

[get_latest_access_human(1)]
description = get_latest_access_human
args = Days_Latest_Access
definition = eval Days_Latest_Access_Display = case (\
    $Days_Latest_Access$ = "0", "Today",\
    $Days_Latest_Access$ = "1", "Yesterday",\
    $Days_Latest_Access$ = "9999999", "Never",\
    true(), $Days_Latest_Access$ . " Days Ago" )

[rename_indexes_fields]
description = rename_indexes_fields
definition = rename \
    currentDBSize_MB AS "Index Size (MB)" \
    currentDBSize_GB AS "Index Size (GB)" \
    currentDBSize_TB AS "Index Size (TB)"\
    homePath_maxDataSizeMB AS "Max Hot/Warm Size (MB)"\
    coldPath_maxDataSizeMB AS "Max Cold Size (MB)"\
    cold_bucket_size_MB AS "Cold Bucket Size (MB)"\
    cold_bucket_size_GB AS "Cold Bucket Size (GB)"\
    cold_bucket_size_TB AS "Cold Bucket Size (TB)"\
    warm_bucket_size_MB AS "Warm Bucket Size (MB)"\
    warm_bucket_size_GB AS "Warm Bucket Size (GB)"\
    warm_bucket_size_TB AS "Warm Bucket Size (TB)"\
    total_bucket_count_avg AS "Avg Bucket Count"\
    app AS App\
    datatype AS "Data Type" \
    datamodel_summary_size_MB AS "Data Model Summary Size (MB)" \
    datamodel_summary_size_GB AS "Data Model Summary Size (GB)" \
    datamodel_summary_size_TB AS "Data Model Summary Size (TB)" \
    idxcluster_label AS "IDX Cluster" \
    Index_Name AS Index \
    Retention_Days AS "Retention IN Days" \
    maxDataSize AS "Max Size of Hot/Warm/Cold Buckets (MB)"\
    HotWarm_Volume AS "Hot/Warm Volume" \
    Cold_Volume AS "Cold Volume" \
    Time_Diff_Days AS "Time Diff IN Days"\
    Days_Diff_From_Retention AS "Days Diff From Retention" \
    maxHotBuckets AS "Max Hot Buckets" \
    maxWarmDBCount AS "Max Warm DB Count" \
    total_bucket_count AS "Average Bucket Count" \
    totalEventCount AS "Average Event Count" \
    maxHotSpanSecs AS "Hot/Warm Bucket Retention IN Days" \
    Num_Splunk_Instances AS "# of Indexers" \
    disabled AS Disabled \
    updated AS "Index Update Time"

[secs_2_days(2)]
description = secs_2_days
args = inField,outField
definition = eval $outField$ = ($inField$/86400)

[gmc_byte2human(2)]
description = gmc_byte2human
args = field,rounding
definition = eval \
    $field$_MB = Round ($field$/1024/1024, $rounding$), \
    $field$_GB = Round ($field$/1024/1024/1024, $rounding$), \
    $field$_TB = Round ($field$/1024/1024/1024/1024, $rounding$)

[gmc_mb2human(2)]
description = gmc_mb2human
args = field,rounding
definition = eval \
    $field$_GB = Round ($field$/1024, $rounding$), \
    $field$_TB = Round ($field$/1024/1024, $rounding$)

[get_splunk_roles_info(2)]
description = get_splunk_roles_info
args = shcluster_label,title
definition = lookup splunk_rest_authorization_roles_sh_kv_store_lookup shcluster_label AS $shcluster_label$ title AS $title$ OUTPUTNEW cumulativeRTSrchJobsQuota,capabilities,imported_capabilities,cumulativeSrchJobsQuota,defaultApp,deleteIndexesAllowed,federatedProviders,grantable_roles,imported_roles,imported_rtSrchJobsQuota,imported_srchDiskQuota,imported_srchFilter,imported_srchIndexesAllowed,imported_srchIndexesDefault,imported_srchJobsQuota,imported_srchTimeWin,rtSrchJobsQuota,srchDiskQuota,srchFilter,srchIndexesAllowed,srchIndexesDefault,srchJobsQuota,srchTimeWin\
| fillnull value="get_splunk_roles_info" splunk_role_map\
| foreach * [ eval <<FIELD>>=mvdedup('<<FIELD>>')]

[rename_splunk_roles_fields]
description = rename_splunk_roles_fields
definition = rename \
    capabilities As "Role-level Capabilities"\
    cumulativeRTSrchJobsQuota As "Role-level Concurrent RT Search job limit (cumulativeRTSrchJobsQuota)"\
    cumulativeSrchJobsQuota As "Role-level Concurrent Search job limit (cumulativeSrchJobsQuota)"\
    defaultApp As "Default App"\
    deleteIndexesAllowed As "Delete Indexes Allowed"\
    federatedProviders As "Role Federated Providers"\
    grantable_roles As "Grantable Roles (grantable_roles)"\
    imported_capabilities As "Inherited Capabilities (imported_capabilities)"\
    imported_roles As "Inherited Roles (imported_roles)"\
    imported_rtSrchJobsQuota As "Inherited User-level Concurrent RT Search job limit (imported_rtSrchJobsQuota)"\
    imported_srchDiskQuota As "Inherited Total Search job disk quota (imported_srchDiskQuota)"\
    imported_srchFilter As "Inherited Restrictions for Search terms"\
    imported_srchIndexesAllowed As "Inherited Allowed Indexes List"\
    imported_srchIndexesDefault As "Inherited Indexes Searched By Default"\
    imported_srchJobsQuota As "Inherited User-level Concurrent search job limit (imported_srchJobsQuota)"\
    imported_srchTimeWin As "Inherited Restrictions for Search time range"\
    rtSrchJobsQuota As "User-level Concurrent RT Search job limit (rtSrchJobsQuota)"\
    srchDiskQuota As "Total Search job disk quota (srchDiskQuota)"\
    srchFilter As "Restricted Search terms (srchFilter)"\
    srchIndexesAllowed As "Allowed Indexes List (srchIndexesAllowed)"\
    srchIndexesDefault As "Indexes Searched By Default (srchIndexesDefault)"\
    srchJobsQuota As "User-level Concurrent search job limit (srchJobsQuota)"\
    srchTimeWin As "Restrict Search time range (srchTimeWin)"\
    title As "Role Name"

[get_sourcetype_info(2)]
description = get_sourcetype_info
args = shcluster_label,title
definition = lookup splunk_rest_configs_conf_props_sh_kv_store_lookup shcluster_label As $shcluster_label$ title As $title$ OUTPUT app sharing author description TIME_PREFIX TIME_FORMAT MAX_TIMESTAMP_LOOKAHEAD DATETIME_CONFIG SHOULD_LINEMERGE LINE_BREAKER TRUNCATE BREAK_ONLY_BEFORE BREAK_ONLY_BEFORE_DATE MUST_BREAK_AFTER KV_MODE INDEXED_EXTRACTIONS EVENT_BREAKER_ENABLE EVENT_BREAKER ANNOTATE_PUNCT LEARN_SOURCETYPE LEARN_MODEL MAX_EVENTS maxDist updated \
| convert ctime(*Time) \
| fillnull value="auto" KV_MODE \
| fillnull value="128" MAX_TIMESTAMP_LOOKAHEAD \
| fillnull value="300" maxDist \
| fillnull value="256" MAX_EVENTS \
| fillnull value="0" EVENT_BREAKER_ENABLE \
| fillnull value="1" ANNOTATE_PUNCT LEARN_MODEL SHOULD_LINEMERGE LEARN_SOURCETYPE BREAK_ONLY_BEFORE_DATE \
| fillnull value="10000" TRUNCATE \
| fillnull value="^" TIME_PREFIX \
| fillnull value="([\r\n]+)" LINE_BREAKER \
| fillnull value="\r\n" EVENT_BREAKER \
| fillnull value="/etc/datetime.xml" DATETIME_CONFIG \
| fillnull value="not-set" INDEXED_EXTRACTIONS

[get_itoa_interface_service_info(3)]
description = get_itoa_interface_service_info
args = shcluster_label,service_id,kpi_id
definition = lookup splunk_rest_itoa_interface_service_sh_kv_store_lookup shcluster_label As $shcluster_label$ service_id As $service_id$ kpi_id As $kpi_id$ OUTPUTNEW service_title kpi_title

[get_itoa_search_name_info(2)]
description = get_itoa_search_name_info
args = shcluster_label,search_name
definition = lookup splunk_index_itsi_summary_sh_kv_store_lookup shcluster_label As $shcluster_label$ search_name As $search_name$ OUTPUTNEW serviceid As service_id kpiid As kpi_id

[get_itoa_kpi_base_search_info(2)]
description = Usage: | `get_itoa_kpi_base_search_info(shcluster_label,base_search_id)`
args = shcluster_label,base_search_id
definition = lookup splunk_rest_itoa_interface_kpi_base_search_sh_kv_store_lookup shcluster_label As $shcluster_label$ key As $base_search_id$ OUTPUT title base_search

[get_sourcetype_info(1)]
description = get_sourcetype_info
args = title
definition = lookup splunk_rest_configs_conf_props_sh_kv_store_lookup title As $title$ OUTPUT app sharing author description TIME_PREFIX TIME_FORMAT MAX_TIMESTAMP_LOOKAHEAD DATETIME_CONFIG SHOULD_LINEMERGE LINE_BREAKER TRUNCATE BREAK_ONLY_BEFORE BREAK_ONLY_BEFORE_DATE MUST_BREAK_AFTER KV_MODE INDEXED_EXTRACTIONS EVENT_BREAKER_ENABLE EVENT_BREAKER ANNOTATE_PUNCT LEARN_SOURCETYPE LEARN_MODEL MAX_EVENTS maxDist updated \
| convert ctime(*Time) \
| fillnull value="auto" KV_MODE \
| fillnull value="128" MAX_TIMESTAMP_LOOKAHEAD \
| fillnull value="300" maxDist \
| fillnull value="256" MAX_EVENTS \
| fillnull value="0" EVENT_BREAKER_ENABLE \
| fillnull value="1" ANNOTATE_PUNCT LEARN_MODEL SHOULD_LINEMERGE LEARN_SOURCETYPE BREAK_ONLY_BEFORE_DATE \
| fillnull value="10000" TRUNCATE \
| fillnull value="^" TIME_PREFIX \
| fillnull value="([\r\n]+)" LINE_BREAKER \
| fillnull value="\r\n" EVENT_BREAKER \
| fillnull value="/etc/datetime.xml" DATETIME_CONFIG \
| fillnull value="not-set" INDEXED_EXTRACTIONS

[license_master]
description = license_master
definition = search_group=dmc_group_license_master

[gmc_summary_index]
description = GMC Summary Index Macro
definition = gmc_summary

[gmc_instance_name]
description = GMC Instance Name or Cluster Label
definition = GMC
